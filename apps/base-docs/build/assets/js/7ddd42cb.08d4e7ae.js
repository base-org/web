"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[919],{82247:(e,t,n)=>{n.d(t,{xA:()=>h,yg:()=>g});var a=n(14041);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=r,g=u["".concat(l,".").concat(d)]||u[d]||p[d]||o;return n?a.createElement(g,i(i({ref:t},h),{},{components:n})):a.createElement(g,i({ref:t},h))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},87501:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(89575),r=(n(14041),n(82247));const o={title:"Testing with Hardhat and Typechain",description:"Testing smart contracts with Hardhat and Typechain.",hide_table_of_contents:!1},i=void 0,s={unversionedId:"docs/hardhat-testing/hardhat-testing-sbs",id:"docs/hardhat-testing/hardhat-testing-sbs",title:"Testing with Hardhat and Typechain",description:"Testing smart contracts with Hardhat and Typechain.",source:"@site/base-camp/docs/hardhat-testing/hardhat-testing-sbs.md",sourceDirName:"docs/hardhat-testing",slug:"/docs/hardhat-testing/hardhat-testing-sbs",permalink:"/base-camp/docs/hardhat-testing/hardhat-testing-sbs",draft:!1,tags:[],version:"current",frontMatter:{title:"Testing with Hardhat and Typechain",description:"Testing smart contracts with Hardhat and Typechain.",hide_table_of_contents:!1},sidebar:"docs",previous:{title:"Contract ABIs and Testing",permalink:"/base-camp/docs/hardhat-testing/contract-abi-and-testing-vid"},next:{title:"Etherscan",permalink:"/base-camp/docs/etherscan/etherscan-sbs"}},l={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Overview",id:"overview",level:2},{value:"Setup Typechain",id:"setup-typechain",level:2},{value:"Writing your first unit test with Typechain",id:"writing-your-first-unit-test-with-typechain",level:3},{value:"Testing <code>unlockTime</code>",id:"testing-unlocktime",level:3},{value:"Testing Ether balance",id:"testing-ether-balance",level:3},{value:"Testing <code>owner</code>",id:"testing-owner",level:3},{value:"Testing withdraw",id:"testing-withdraw",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"See also",id:"see-also",level:2}],h={toc:c},u="wrapper";function p(e){let{components:t,...o}=e;return(0,r.yg)(u,(0,a.A)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"In this article, you'll learn how to test smart contracts with Hardhat and Typechain."),(0,r.yg)("hr",null),(0,r.yg)("h2",{id:"objectives"},"Objectives"),(0,r.yg)("p",null,"By the end of this lesson, you should be able to:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Set up TypeChain to enable testing"),(0,r.yg)("li",{parentName:"ul"},"Write unit tests for smart contracts using Mocha, Chai, and the Hardhat Toolkit"),(0,r.yg)("li",{parentName:"ul"},"Set up multiple signers and call smart contract functions with different signers")),(0,r.yg)("hr",null),(0,r.yg)("h2",{id:"overview"},"Overview"),(0,r.yg)("p",null,"Testing is an important aspect of software development and developing smart contracts is no different. In fact, you need to be more careful because\nsmart contracts usually manage money and live in an adversarial environment, where anyone can see the code and interact with your smart contract. This means you can expect bad actors to try to exploit your smart contracts."),(0,r.yg)("h2",{id:"setup-typechain"},"Setup Typechain"),(0,r.yg)("p",null,"In the previous guide, you created a new project using the ",(0,r.yg)("inlineCode",{parentName:"p"},"init")," command that by default installs ",(0,r.yg)("inlineCode",{parentName:"p"},"@nomicfoundation/hardhat-toolbox"),". This package already contains Typechain, which is a plugin that generates static types for your smart contracts. This means you can interact with your contracts and get immediate feedback about the parameters received by a particular function and the functions of a smart contract."),(0,r.yg)("p",null,"The best way to see its true potential is to start writing tests."),(0,r.yg)("p",null,"After compiling the hardhat project in the previous lesson, a new folder called ",(0,r.yg)("inlineCode",{parentName:"p"},"typechain-types")," was created, which Typechain is already installed and running."),(0,r.yg)("h3",{id:"writing-your-first-unit-test-with-typechain"},"Writing your first unit test with Typechain"),(0,r.yg)("p",null,"Hardhat includes a sample smart contract named ",(0,r.yg)("inlineCode",{parentName:"p"},"Lock.sol")," and a sample test inside the test folder named ",(0,r.yg)("inlineCode",{parentName:"p"},"Lock.ts"),"."),(0,r.yg)("p",null,"In the following, you reuse this smart contract but rewrite the test using Typechain."),(0,r.yg)("p",null,"To remove the body of the ",(0,r.yg)("inlineCode",{parentName:"p"},"Lock.ts")," file:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},"import { expect } from 'chai';\nimport { ethers } from 'hardhat';\n\ndescribe('Lock', function () {});\n")),(0,r.yg)("p",null,"Then, import two files from ",(0,r.yg)("inlineCode",{parentName:"p"},"typechain-types"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"Lock"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"Lock__Factory"),"."),(0,r.yg)("p",null,"Typechain always creates two files per contract. The first one ",(0,r.yg)("inlineCode",{parentName:"p"},"Lock")," refers to the type and functions of a particular contract. ",(0,r.yg)("inlineCode",{parentName:"p"},"Lock__Factory")," is used to deploy the Lock contract or to create instances of a particular contract."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Lock.sol")," contract allows the creator to lock Ether until an unlock time has passed."),(0,r.yg)("p",null,"Notice the constructor has a payable keyword:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},'constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp < _unlockTime,\n            "Unlock time should be in the future"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n    }\n')),(0,r.yg)("p",null,"This means the contract is expecting to receive an amount of ether."),(0,r.yg)("p",null,"Next, test the following:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The unlock time value"),(0,r.yg)("li",{parentName:"ul"},"The value locked during creation"),(0,r.yg)("li",{parentName:"ul"},"The owner address"),(0,r.yg)("li",{parentName:"ul"},"The withdraw function")),(0,r.yg)("details",null,(0,r.yg)("summary",null,"Reveal code"),(0,r.yg)("p",null,"Start with the value locked, however you must set up a ",(0,r.yg)("inlineCode",{parentName:"p"},"before")," function, which will run before each test case."),(0,r.yg)("p",null,"Then, include some new imports and variables:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},"import { expect } from 'chai';\nimport { ethers } from 'hardhat';\n\n// A helper utility to get the timestamp.\nimport { time } from '@nomicfoundation/hardhat-network-helpers';\n\n// We import this type to have our signers typed.\nimport { SignerWithAddress } from '@nomicfoundation/hardhat-ethers/signers';\n\n// Types from typechain\nimport { Lock__factory, Lock } from '../typechain-types';\n\ndescribe('Lock', function () {\n  // This represents the time in the future we expect to release the funds locked.\n  const UNLOCK_TIME = 10000;\n\n  // The amount of ether we plan to lock.\n  const VALUE_LOCKED = ethers.parseEther('0.01');\n\n  // This variable will store the last block timestamp.\n  let lastBlockTimeStamp: number;\n\n  // Typechain allow us to type an instance of the Lock contract.\n  let lockInstance: Lock;\n\n  // This is the Signer of the owner.\n  let ownerSigner: SignerWithAddress;\n\n  // A non owner signed is useful to test non owner transactions.\n  let otherUserSigner: SignerWithAddress;\n\n  before(async () => {\n    // We get the latest block.timestamp using the latest function of time.\n    lastBlockTimeStamp = await time.latest();\n\n    // Hardhat provide us with some sample signers that simulate Ethereum accounts.\n    const signers = await ethers.getSigners();\n\n    // We simply assign the first signer to ownerSigner\n    ownerSigner = signers[0];\n\n    // We assign the second signer to otherUserSigner\n    otherUserSigner = signers[1];\n\n    // We estimate unlockTime to be the last time stamp plus UNLOCK_TIME\n    const unlockTime = lastBlockTimeStamp + UNLOCK_TIME;\n\n    // Notice how we use the Lock__factory and pass a signer. Then we deploy by passing the unlockTime and the amount of ether we will lock.\n    lockInstance = await new Lock__factory(ownerSigner).deploy(unlockTime, {\n      value: VALUE_LOCKED,\n    });\n  });\n});\n"))),(0,r.yg)("h3",{id:"testing-unlocktime"},"Testing ",(0,r.yg)("inlineCode",{parentName:"h3"},"unlockTime")),(0,r.yg)("p",null,"Next, you include test cases after the ",(0,r.yg)("inlineCode",{parentName:"p"},"before")," function."),(0,r.yg)("p",null,"The first test case should verify that the ",(0,r.yg)("inlineCode",{parentName:"p"},"unlockTime")," variable is correct."),(0,r.yg)("details",null,(0,r.yg)("summary",null,"Reveal code"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},"it('should get the unlockTime value', async () => {\n  // we get the value from the contract\n  const unlockTime = await lockInstance.unlockTime();\n\n  // We assert against the\n  expect(unlockTime).to.equal(lastBlockTimeStamp + UNLOCK_TIME);\n});\n")),(0,r.yg)("p",null,"Notice how autocomplete appears after entering ",(0,r.yg)("inlineCode",{parentName:"p"},"lockInstance"),":"),(0,r.yg)("p",null,(0,r.yg)("img",{alt:"Auto complete",src:n(41545).A,width:"742",height:"112"})),(0,r.yg)("p",null,"You can simply run ",(0,r.yg)("inlineCode",{parentName:"p"},"npx hardhat test")," and then get:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"  Lock\n    \u2714 should get the unlockTime value\n\n  1 passing (1s)\n"))),(0,r.yg)("h3",{id:"testing-ether-balance"},"Testing Ether balance"),(0,r.yg)("p",null,"In order to get the balance of your ",(0,r.yg)("inlineCode",{parentName:"p"},"Lock")," contract, you simply call ",(0,r.yg)("inlineCode",{parentName:"p"},"ethers.provider.getBalance"),"."),(0,r.yg)("p",null,"Create a new test case:"),(0,r.yg)("details",null,(0,r.yg)("summary",null,"Reveal code"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},"it('should have the right ether balance', async () => {\n  // Get the Lock contract address\n  const lockInstanceAddress = await lockInstance.getAddress();\n\n  // Get the balance using ethers.provider.getBalance\n  const contractBalance = await ethers.provider.getBalance(lockInstanceAddress);\n\n  // We assert the balance against the VALUE_LOCKED we initially sent\n  expect(contractBalance).to.equal(VALUE_LOCKED);\n});\n"))),(0,r.yg)("br",null),(0,r.yg)("p",null,"Then, run ",(0,r.yg)("inlineCode",{parentName:"p"},"npx hardhat test")," and you should get:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"  Lock\n    \u2714 should get the unlockTime value\n    \u2714 should have the right ether balance\n\n  2 passing (1s)\n")),(0,r.yg)("h3",{id:"testing-owner"},"Testing ",(0,r.yg)("inlineCode",{parentName:"h3"},"owner")),(0,r.yg)("p",null,"Similar to the previous test cases, you can verify that the owner is correct."),(0,r.yg)("details",null,(0,r.yg)("summary",null,"Reveal code"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},"it('should have the right owner', async () => {\n  // Notice ownerSigned has an address property\n  expect(await lockInstance.owner()).to.equal(ownerSigner.address);\n});\n"))),(0,r.yg)("br",null),(0,r.yg)("p",null,"Then, run ",(0,r.yg)("inlineCode",{parentName:"p"},"npx hardhat test")," and you should get:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"  Lock\n    \u2714 should get the unlockTime value\n    \u2714 should have the right ether balance\n    \u2714 should have the right owner\n\n  3 passing (1s)\n")),(0,r.yg)("h3",{id:"testing-withdraw"},"Testing withdraw"),(0,r.yg)("p",null,"Testing withdrawal is more complex because you need to assert certain conditions, such as:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The owner cannot withdraw before the unlock time."),(0,r.yg)("li",{parentName:"ul"},"Only the owner can withdraw."),(0,r.yg)("li",{parentName:"ul"},"The withdraw function works as expected.")),(0,r.yg)("p",null,"Hardhat allow you to test reverts with a set of custom matchers."),(0,r.yg)("p",null,"For example, the following code checks that an attempt to call the function ",(0,r.yg)("inlineCode",{parentName:"p"},"withdraw")," reverts with a particular message:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},"it('shouldn\"t allow to withdraw before unlock time', async () => {\n  await expect(lockInstance.withdraw()).to.be.revertedWith(\"You can't withdraw yet\");\n});\n")),(0,r.yg)("p",null,"In addition, Hardhat also allows you to manipulate the time of the environment where the tests are executed. You can think of it as a Blockchain that is running before the tests and then the tests are executed against it."),(0,r.yg)("p",null,"You can modify ",(0,r.yg)("inlineCode",{parentName:"p"},"the block.timestamp")," by using the time helper:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},"it('shouldn\"t allow to withdraw a non owner', async () => {\n  const newLastBlockTimeStamp = await time.latest();\n\n  // We set the next block time stamp using this helper.\n  // We assign a value further in the future.\n  await time.setNextBlockTimestamp(newLastBlockTimeStamp + UNLOCK_TIME);\n\n  // Then we try to withdraw using other user signer. Notice the .connect function that is useful\n  //  to create and instance but have the msg.sender as the new signer.\n  const newInstanceUsingAnotherSigner = lockInstance.connect(otherUserSigner);\n\n  // We attempt to withdraw, but since the sender is not the owner, it will revert.\n  await expect(newInstanceUsingAnotherSigner.withdraw()).to.be.revertedWith(\"You aren't the owner\");\n});\n")),(0,r.yg)("p",null,"Finally, test that the owner can withdraw. You can manipulate the time similarly to the previous test case but you won't change the signer and will assert the new balances."),(0,r.yg)("details",null,(0,r.yg)("summary",null,"Reveal code"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},"it('should allow to withdraw a owner', async () => {\n  const balanceBefore = await ethers.provider.getBalance(await lockInstance.getAddress());\n\n  // Its value will be the one we lock at deployment time.\n  expect(balanceBefore).to.equal(VALUE_LOCKED);\n\n  const newLastBlockTimeStamp = await time.latest();\n\n  // We increase time\n  await time.setNextBlockTimestamp(newLastBlockTimeStamp + UNLOCK_TIME);\n\n  // Attempt to withdraw\n  await lockInstance.withdraw();\n\n  // Get new balance and assert that is 0\n  const balanceAfter = await ethers.provider.getBalance(await lockInstance.getAddress());\n  expect(balanceAfter).to.equal(0);\n});\n"))),(0,r.yg)("br",null),(0,r.yg)("p",null,"You can then run ",(0,r.yg)("inlineCode",{parentName:"p"},"npx hardhat test")," and you should get:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},'  Lock\n    \u2714 should get the unlockTime value\n    \u2714 should have the right ether balance\n    \u2714 should have the right owner\n    \u2714 shouldn"t allow to withdraw before unlock time (51ms)\n    \u2714 shouldn"t allow to withdraw a non owner\n    \u2714 should allow to withdraw a owner\n\n  6 passing (2s)\n')),(0,r.yg)("h2",{id:"conclusion"},"Conclusion"),(0,r.yg)("p",null,"In this lesson, you've learned how to test smart contracts using Hardhat and Typechain."),(0,r.yg)("hr",null),(0,r.yg)("h2",{id:"see-also"},"See also"),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/"},"Solidity Docs")))}p.isMDXComponent=!0},41545:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/autocomplete-unlockTime-fe44b97d89e72c4cb6bade9b90274e86.png"}}]);