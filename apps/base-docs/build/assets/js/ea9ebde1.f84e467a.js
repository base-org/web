"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[799],{82247:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>y});var o=n(14041);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),u=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=u(e.components);return o.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},g=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=u(n),g=r,y=d["".concat(l,".").concat(g)]||d[g]||p[g]||s;return n?o.createElement(y,a(a({ref:t},c),{},{components:n})):o.createElement(y,a({ref:t},c))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,a=new Array(s);a[0]=g;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:r,a[1]=i;for(var u=2;u<s;u++)a[u]=n[u];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}g.displayName="MDXCreateElement"},45874:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>u});var o=n(89575),r=(n(14041),n(82247));const s={title:"Foundry: Testing smart contracts",slug:"/intro-to-foundry-testing",author:"Edson Alcala",description:"A tutorial that teaches how to test your smart contracts using Foundry.",keywords:["Foundry","Forge","Foundry Book","smart contract development","toolchain","testing","test"],tags:["smart contracts"],difficulty:"beginner",hide_table_of_contents:!1,displayed_sidebar:null},a=void 0,i={unversionedId:"docs/intro-to-foundry-testing",id:"docs/intro-to-foundry-testing",title:"Foundry: Testing smart contracts",description:"A tutorial that teaches how to test your smart contracts using Foundry.",source:"@site/tutorials/docs/4_intro-to-foundry-testing.md",sourceDirName:"docs",slug:"/intro-to-foundry-testing",permalink:"/tutorials/intro-to-foundry-testing",draft:!1,tags:[{label:"smart contracts",permalink:"/tutorials/tags/smart-contracts"}],version:"current",sidebarPosition:4,frontMatter:{title:"Foundry: Testing smart contracts",slug:"/intro-to-foundry-testing",author:"Edson Alcala",description:"A tutorial that teaches how to test your smart contracts using Foundry.",keywords:["Foundry","Forge","Foundry Book","smart contract development","toolchain","testing","test"],tags:["smart contracts"],difficulty:"beginner",hide_table_of_contents:!1,displayed_sidebar:null}},l={},u=[{value:"Objectives",id:"objectives",level:2},{value:"Overview",id:"overview",level:2},{value:"My First Test with Foundry",id:"my-first-test-with-foundry",level:2},{value:"Using Cheatcodes",id:"using-cheatcodes",level:2},{value:"Conclusion",id:"conclusion",level:2}],c={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.yg)(d,(0,o.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"In this tutorial, you'll learn how to test your smart contracts using ",(0,r.yg)("a",{parentName:"p",href:"https://book.getfoundry.sh/"},"Foundry"),", the toolchain for smart contract development."),(0,r.yg)("hr",null),(0,r.yg)("h2",{id:"objectives"},"Objectives"),(0,r.yg)("p",null,"By the end of this tutorial, you should be able to:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Understand the increased importance of testing in smart contract development"),(0,r.yg)("li",{parentName:"ul"},"Write and execute tests written in Solidity using the Forge Standard Library with Foundry"),(0,r.yg)("li",{parentName:"ul"},"Use the ",(0,r.yg)("inlineCode",{parentName:"li"},"cheatcodes")," that Foundry provides to test your smart contracts")),(0,r.yg)("h2",{id:"overview"},"Overview"),(0,r.yg)("p",null,"Testing is a crucial aspect of smart contract development, ensuring the reliability and security of your code. Because it is impossible to patch a smart contract after deployment, you must thoroughly and completely test your code. Foundry provides a robust testing framework that allows developers to create comprehensive test suites for their projects using Solidity."),(0,r.yg)("h2",{id:"my-first-test-with-foundry"},"My First Test with Foundry"),(0,r.yg)("p",null,"Consider the default test that the ",(0,r.yg)("inlineCode",{parentName:"p"},"forge init hello_foundry_in_base")," command provides in the seed Foundry project."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport "forge-std/Test.sol";\nimport "../src/Counter.sol";\n\ncontract CounterTest is Test {\n    Counter public counter;\n\n    function setUp() public {\n        counter = new Counter();\n        counter.setNumber(0);\n    }\n\n    function testIncrement() public {\n        counter.increment();\n        assertEq(counter.number(), 1);\n    }\n\n    function testSetNumber(uint256 x) public {\n        counter.setNumber(x);\n        assertEq(counter.number(), x);\n    }\n}\n')),(0,r.yg)("p",null,"Take note of the following:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Foundry test files are named following the pattern: ",(0,r.yg)("inlineCode",{parentName:"li"},"<ContractName>.t.sol")),(0,r.yg)("li",{parentName:"ul"},"Smart contract test files are named following the pattern: ",(0,r.yg)("inlineCode",{parentName:"li"},"<ContractName>Test")),(0,r.yg)("li",{parentName:"ul"},"All tests inherit from ",(0,r.yg)("inlineCode",{parentName:"li"},"forge-std/Test.sol"),"."),(0,r.yg)("li",{parentName:"ul"},"All tests contain a public function called ",(0,r.yg)("inlineCode",{parentName:"li"},"setUp"),", which is executed before each test. This is similar to the ",(0,r.yg)("inlineCode",{parentName:"li"},"beforeEach")," hook in the Mocha/Typescript world."),(0,r.yg)("li",{parentName:"ul"},"Test cases start with the ",(0,r.yg)("inlineCode",{parentName:"li"},"test")," keyword, for instance ",(0,r.yg)("inlineCode",{parentName:"li"},"testIncrement"),"."),(0,r.yg)("li",{parentName:"ul"},"Test cases functions are public.")),(0,r.yg)("p",null,"For more information about writing tests in Foundry, you can follow the official guide for ",(0,r.yg)("a",{parentName:"p",href:"https://book.getfoundry.sh/forge/writing-tests"},"Writing tests")),(0,r.yg)("p",null,"In order to run the test in Foundry, run:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"$ forge test\n")),(0,r.yg)("p",null,"You should see in the terminal:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"Running 2 tests for test/Counter.t.sol:CounterTest\n[PASS] testIncrement() (gas: 28334)\n[PASS] testSetNumber(uint256) (runs: 256, \u03bc: 27565, ~: 28343)\nTest result: ok. 2 passed; 0 failed; finished in 13.57ms\n")),(0,r.yg)("h2",{id:"using-cheatcodes"},"Using Cheatcodes"),(0,r.yg)("p",null,"Foundry includes a set of ",(0,r.yg)("a",{parentName:"p",href:"https://book.getfoundry.sh/forge/cheatcodes"},"cheatcodes"),", which are special instructions that are accessible using the ",(0,r.yg)("inlineCode",{parentName:"p"},"vm")," instance in your tests. Cheatcodes allow you to perform various tasks, including:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Manipulate the state of the blockchain"),(0,r.yg)("li",{parentName:"ul"},"Test reverts"),(0,r.yg)("li",{parentName:"ul"},"Test events"),(0,r.yg)("li",{parentName:"ul"},"Change block number"),(0,r.yg)("li",{parentName:"ul"},"Change identity"),(0,r.yg)("li",{parentName:"ul"},"And more!")),(0,r.yg)("p",null,"To start, use a cheatcode to modify the ",(0,r.yg)("inlineCode",{parentName:"p"},"msg.sender")," of your tests, and add some console logs via importing the ",(0,r.yg)("inlineCode",{parentName:"p"},"forge-std/console.sol")," contract."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Counter")," contract should look as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport "forge-std/console.sol";\n\ncontract Counter {\n    uint256 public number;\n\n    function setNumber(uint256 newNumber) public {\n        console.log("The sender is %s", msg.sender);\n        number = newNumber;\n    }\n\n    function increment() public {\n        console.log("The sender is %s", msg.sender);\n        number++;\n    }\n}\n')),(0,r.yg)("p",null,"If you run the tests using ",(0,r.yg)("inlineCode",{parentName:"p"},"forge test"),", you will see the following:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"Running 2 tests for test/Counter.t.sol:CounterTest\n[PASS] testIncrement() (gas: 31531)\n[PASS] testSetNumber(uint256) (runs: 256, \u03bc: 30684, ~: 31540)\nTest result: ok. 2 passed; 0 failed; finished in 19.64ms\n")),(0,r.yg)("p",null,"It seems the logs are not being shown. The reason is because the ",(0,r.yg)("inlineCode",{parentName:"p"},"forge test")," command includes a flag that enable you to include more details of the logs emitted during the execution of the tests."),(0,r.yg)("p",null,"You can control that by including different levels of the verbose flag -- ",(0,r.yg)("inlineCode",{parentName:"p"},"-vv")," up to ",(0,r.yg)("inlineCode",{parentName:"p"},"-vvvvv"),". For more details about the level of verbosity you can refer to the ",(0,r.yg)("a",{parentName:"p",href:"https://book.getfoundry.sh/forge/tests?highlight=vvv#logs-and-traces"},"Logs and Traces")," section of the Foundry documentation."),(0,r.yg)("p",null,"Run the ",(0,r.yg)("inlineCode",{parentName:"p"},"foundry test -vv"),". You should see:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"Running 2 tests for test/Counter.t.sol:CounterTest\n[PASS] testIncrement() (gas: 31531)\nLogs:\n  The sender is 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n  The sender is 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n\n[PASS] testSetNumber(uint256) (runs: 256, \u03bc: 30607, ~: 31540)\nLogs:\n  The sender is 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n\nTest result: ok. 2 passed; 0 failed; finished in 17.89ms\n")),(0,r.yg)("p",null,"Now, modify the test file using ",(0,r.yg)("inlineCode",{parentName:"p"},"prank")," cheatcode, which allow you to modify the ",(0,r.yg)("inlineCode",{parentName:"p"},"msg.sender")," of the next transaction. You will also use the ",(0,r.yg)("inlineCode",{parentName:"p"},"addr")," cheatcode, which allow you to generate an address using any private key, which can simply be a hex number."),(0,r.yg)("p",null,"Include some ",(0,r.yg)("inlineCode",{parentName:"p"},"console.log")," statements to understand better the execution flow."),(0,r.yg)("p",null,"The code should look like:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport "forge-std/Test.sol";\nimport "../src/Counter.sol";\n\ncontract CounterTest is Test {\n    Counter public counter;\n\n    function setUp() public {\n        counter = new Counter();\n        console.log("Calling on Setup");\n        counter.setNumber(0);\n    }\n\n    function testIncrement() public {\n        console.log("Calling on testIncrement");\n        vm.prank(vm.addr(0x01));\n        counter.increment();\n        assertEq(counter.number(), 1);\n    }\n\n    function testSetNumber(uint256 x) public {\n        console.log("Calling on testSetNumber");\n        vm.prank(vm.addr(0x02));\n        counter.setNumber(x);\n        assertEq(counter.number(), x);\n    }\n}\n')),(0,r.yg)("p",null,"Then if you run the ",(0,r.yg)("inlineCode",{parentName:"p"},"forge test -vv")," command, you should see:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"Running 2 tests for test/Counter.t.sol:CounterTest\n[PASS] testIncrement() (gas: 35500)\nLogs:\n  Calling on Setup\n  The sender is 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n  Calling on testIncrement\n  The sender is 0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf\n\n[PASS] testSetNumber(uint256) (runs: 256, \u03bc: 34961, ~: 35506)\nLogs:\n  Calling on Setup\n  The sender is 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496\n\nTest result: ok. 2 passed; 0 failed; finished in 48.75ms\n")),(0,r.yg)("p",null,"Notice how you call the cheatcode ",(0,r.yg)("inlineCode",{parentName:"p"},"vm.prank")," before the call to the ",(0,r.yg)("inlineCode",{parentName:"p"},"counter.increment()")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"counter.setNumber(x)")," functions. This allows you to specify a particular address to become the ",(0,r.yg)("inlineCode",{parentName:"p"},"msg.sender")," in the contract. Since the ",(0,r.yg)("inlineCode",{parentName:"p"},"vm.prank")," accepts an address, you simply generate an address using the cheatcode ",(0,r.yg)("inlineCode",{parentName:"p"},"vm.addr"),", where you pass a simple hexadecimal number, which is a valid private key."),(0,r.yg)("h2",{id:"conclusion"},"Conclusion"),(0,r.yg)("p",null,"Congratulations! You've successfully completed your first step in your journey of testing smart contracts using Foundry. As you move forward, keep exploring its rich features and functionalities. The ability to write comprehensive tests and leverage cheatcodes ensures the reliability and security of your smart contracts."),(0,r.yg)("p",null,"Happy coding and testing with Foundry!"),(0,r.yg)("hr",null))}p.isMDXComponent=!0}}]);