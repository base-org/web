"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[8217],{30876:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var r=t(2784);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),p=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(c.Provider,{value:n},e.children)},s="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),s=p(t),d=a,h=s["".concat(c,".").concat(d)]||s[d]||m[d]||o;return t?r.createElement(h,i(i({ref:n},u),{},{components:t})):r.createElement(h,i({ref:n},u))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[s]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},46240:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=t(7896),a=(t(2784),t(30876));const o={title:"Multiple Inheritance",description:"Learn how to have a contract inherit from multiple contracts.",hide_table_of_contents:!1},i=void 0,l={unversionedId:"docs/inheritance/multiple-inheritance",id:"docs/inheritance/multiple-inheritance",title:"Multiple Inheritance",description:"Learn how to have a contract inherit from multiple contracts.",source:"@site/base-camp/docs/inheritance/multiple-inheritance.md",sourceDirName:"docs/inheritance",slug:"/docs/inheritance/multiple-inheritance",permalink:"/es/base-camp/docs/inheritance/multiple-inheritance",draft:!1,tags:[],version:"current",frontMatter:{title:"Multiple Inheritance",description:"Learn how to have a contract inherit from multiple contracts.",hide_table_of_contents:!1},sidebar:"docs",previous:{title:"Multiple Inheritance",permalink:"/es/base-camp/docs/inheritance/multiple-inheritance-vid"},next:{title:"Abstract Contracts",permalink:"/es/base-camp/docs/inheritance/abstract-contracts-vid"}},c={},p=[{value:"Objectives",id:"objectives",level:2},{value:"Multiple Inheritance",id:"multiple-inheritance",level:2},{value:"Inheriting from Two Contracts",id:"inheriting-from-two-contracts",level:3},{value:"Using Virtual and Override",id:"using-virtual-and-override",level:3},{value:"Changing Types Dynamically",id:"changing-types-dynamically",level:3},{value:"Final Code",id:"final-code",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:p},s="wrapper";function m(e){let{components:n,...t}=e;return(0,a.kt)(s,(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Contracts can inherit from more than one contract. In this lesson, we'll explore how multiple inheritance works in Solidity."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"objectives"},"Objectives"),(0,a.kt)("p",null,"By the end of this lesson you should be able to:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Write a smart contract that inherits from multiple contracts")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"multiple-inheritance"},"Multiple Inheritance"),(0,a.kt)("p",null,"Continue working with your contracts in ",(0,a.kt)("inlineCode",{parentName:"p"},"Inheritance.sol"),". Add a new contract called ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractC")," with another ",(0,a.kt)("inlineCode",{parentName:"p"},"whoAmI")," function:"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Reveal code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'contract ContractC {\n    function whoAmI() external pure returns (string memory) {\n        return "contract C";\n    }\n}\n'))),(0,a.kt)("br",null),(0,a.kt)("h3",{id:"inheriting-from-two-contracts"},"Inheriting from Two Contracts"),(0,a.kt)("p",null,"You can inherit from additional contracts by simply adding a comma and that contract's name after the first. Add inheritance from ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractC")," (an error is expected):"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Reveal code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// bad code example, do not use\ncontract ContractA is ContractB, ContractC {\n    function whoAmExternal() external pure returns (string memory) {\n        return whoAmIInternal();\n    }\n}\n"))),(0,a.kt)("br",null),(0,a.kt)("p",null,"The error is because both ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractB")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractC")," contain a function called ",(0,a.kt)("inlineCode",{parentName:"p"},"whoAmI"),". As a result, the compiler needs instruction on which to use."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'from solidity:\nTypeError: Derived contract must override function "whoAmI". Two or more base classes define function with same name and parameter types.\n  --\x3e contracts/Inheritance.sol:21:1:\n   |\n21 | contract ContractA is ContractB, ContractC {\n   | ^ (Relevant source part starts here and spans across multiple lines).\nNote: Definition in "ContractC":\n --\x3e contracts/Inheritance.sol:6:5:\n  |\n6 |     function whoAmI() external pure returns (string memory) {\n  |     ^ (Relevant source part starts here and spans across multiple lines).\nNote: Definition in "ContractB":\n  --\x3e contracts/Inheritance.sol:12:5:\n   |\n12 |     function whoAmI() external pure returns (string memory) {\n   |     ^ (Relevant source part starts here and spans across multiple lines).\n')),(0,a.kt)("h3",{id:"using-virtual-and-override"},"Using Virtual and Override"),(0,a.kt)("p",null,"One method to resolve this conflict is to use the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/contracts.html?#function-overriding"},(0,a.kt)("inlineCode",{parentName:"a"},"virtual")," and ",(0,a.kt)("inlineCode",{parentName:"a"},"override"))," keywords to enable you to add functionality to choose which to call."),(0,a.kt)("p",null,"Add the ",(0,a.kt)("inlineCode",{parentName:"p"},"virtual")," keyword to the ",(0,a.kt)("inlineCode",{parentName:"p"},"whoAmI")," function in both ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractC")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractB"),"."),(0,a.kt)("p",null,"They must also be made ",(0,a.kt)("inlineCode",{parentName:"p"},"public")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"external"),", because ",(0,a.kt)("inlineCode",{parentName:"p"},"external")," functions cannot be called within the contract."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'contract ContractC {\n    function whoAmI() public virtual pure returns (string memory) {\n        return "contract C";\n    }\n}\n\ncontract ContractB {\n    function whoAmI() public virtual pure returns (string memory) {\n        return "contract B";\n    }\n\n    // ... additional code\n}\n')),(0,a.kt)("p",null,"Add an ",(0,a.kt)("inlineCode",{parentName:"p"},"override")," function called ",(0,a.kt)("inlineCode",{parentName:"p"},"whoAmI")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractA"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// Bad code example, do not use\nfunction whoAmI() public override pure returns (string memory) {\n    return ContractB.whoAmI();\n}\n")),(0,a.kt)("p",null,"You'll get another error, telling you to specify which contracts this function should override."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'from solidity:\nTypeError: Function needs to specify overridden contracts "ContractB" and "ContractC".\n  --\x3e contracts/Inheritance.sol:22:32:\n   |\n22 |     function whoAmI() public override pure returns (string memory) {\n   |                              ^^^^^^^^\n')),(0,a.kt)("p",null,"Add them both:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function whoAmI() external override(ContractB, ContractC) pure returns (string memory) {\n    return ContractB.whoAmI();\n}\n")),(0,a.kt)("p",null,'Deploy and test. The call will now be back to reporting "contract B".'),(0,a.kt)("h3",{id:"changing-types-dynamically"},"Changing Types Dynamically"),(0,a.kt)("p",null,"Add an ",(0,a.kt)("inlineCode",{parentName:"p"},"enum")," at the contract level in ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractA")," with members for ",(0,a.kt)("inlineCode",{parentName:"p"},"None"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractBType"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractCType"),", and an instance of it called ",(0,a.kt)("inlineCode",{parentName:"p"},"contractType"),"."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Reveal code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"enum Type { None, ContractBType, ContractCType }\n\nType contractType;\n"))),(0,a.kt)("br",null),(0,a.kt)("p",null,"Add a ",(0,a.kt)("inlineCode",{parentName:"p"},"constructor")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractA")," that accepts a ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," and sets ",(0,a.kt)("inlineCode",{parentName:"p"},"initialType"),"."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Reveal code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"constructor (Type _initialType) {\n    contractType = _initialType;\n}\n"))),(0,a.kt)("br",null),(0,a.kt)("p",null,"Update ",(0,a.kt)("inlineCode",{parentName:"p"},"whoAmI")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"ContractA")," to call the appropriate ",(0,a.kt)("inlineCode",{parentName:"p"},"virtual")," function based on its ",(0,a.kt)("inlineCode",{parentName:"p"},"currentType"),"."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Reveal code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// Bad code example, do not use\nfunction whoAmI() public override(ContractB, ContractC) pure returns (string memory) {\n    if(contractType == Type.ContractBType) {\n        return ContractB.whoAmI();\n    }\n    if(contractType == Type.ContractCType) {\n        return ContractC.whoAmI();\n    }\n    return "contract A";\n}\n'))),(0,a.kt)("br",null),(0,a.kt)("p",null,"You'll get errors because the function now reads from state, so it is no longer ",(0,a.kt)("inlineCode",{parentName:"p"},"pure"),". Update it to ",(0,a.kt)("inlineCode",{parentName:"p"},"view"),". You'll also have to update the ",(0,a.kt)("inlineCode",{parentName:"p"},"whoAmI")," ",(0,a.kt)("inlineCode",{parentName:"p"},"virtual")," functions to ",(0,a.kt)("inlineCode",{parentName:"p"},"view")," to match."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Reveal code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'function whoAmI() public override(ContractB, ContractC) view returns (string memory) {\n    if(contractType == Type.ContractBType) {\n        return ContractB.whoAmI();\n    }\n    if(contractType == Type.ContractCType) {\n        return ContractC.whoAmI();\n    }\n    return "contract A";\n}\n'))),(0,a.kt)("br",null),(0,a.kt)("p",null,"Finally, add a function that allows you to switch ",(0,a.kt)("inlineCode",{parentName:"p"},"currentType"),":"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Reveal code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function changeType(Type _newType) external {\n    contractType = _newType;\n}\n"))),(0,a.kt)("br",null),(0,a.kt)("p",null,"Deploy and test. You'll need to use ",(0,a.kt)("strong",{parentName:"p"},"0"),", ",(0,a.kt)("strong",{parentName:"p"},"1"),", and ",(0,a.kt)("strong",{parentName:"p"},"2")," as values to set ",(0,a.kt)("inlineCode",{parentName:"p"},"contractType"),", because Remix won't know about your ",(0,a.kt)("inlineCode",{parentName:"p"},"enum"),"."),(0,a.kt)("h2",{id:"final-code"},"Final Code"),(0,a.kt)("p",null,"After completing this exercise, you should have something similar to:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.17;\n\ncontract ContractC {\n    function whoAmI() public virtual view returns (string memory) {\n        return "contract C";\n    }\n}\n\ncontract ContractB {\n    function whoAmI() public virtual view returns (string memory) {\n        return "contract B";\n    }\n\n    function whoAmIInternal() internal pure returns (string memory) {\n        return "contract B";\n    }\n}\n\ncontract ContractA is ContractB, ContractC {\n    enum Type { None, ContractBType, ContractCType }\n\n    Type contractType;\n\n    constructor (Type _initialType) {\n        contractType = _initialType;\n    }\n\n    function changeType(Type _newType) external {\n        contractType = _newType;\n    }\n\n    function whoAmI() public override(ContractB, ContractC) view returns (string memory) {\n        if(contractType == Type.ContractBType) {\n            return ContractB.whoAmI();\n        }\n        if(contractType == Type.ContractCType) {\n            return ContractC.whoAmI();\n        }\n        return "contract A";\n    }\n\n    function whoAmExternal() external pure returns (string memory) {\n        return whoAmIInternal();\n    }\n}\n')),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"In this lesson, you've explored how to use multiple inheritance to import additional functionality into a contract. You've also implemented one approach to resolving name conflicts between those contracts."),(0,a.kt)("hr",null))}m.isMDXComponent=!0}}]);