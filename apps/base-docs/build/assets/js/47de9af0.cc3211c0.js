"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[13],{82247:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>h});var a=n(14041);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),d=r,h=p["".concat(s,".").concat(d)]||p[d]||m[d]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},56653:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(89575),r=(n(14041),n(82247));const o={title:"The `useSimulateContract` hook",description:"Improve your user experience with the `useSimulateContract` hook.",hide_table_of_contents:!1},i=void 0,l={unversionedId:"docs/writing-to-contracts/useSimulateContract",id:"docs/writing-to-contracts/useSimulateContract",title:"The `useSimulateContract` hook",description:"Improve your user experience with the `useSimulateContract` hook.",source:"@site/base-camp/docs/writing-to-contracts/useSimulateContract.md",sourceDirName:"docs/writing-to-contracts",slug:"/docs/writing-to-contracts/useSimulateContract",permalink:"/base-camp/docs/writing-to-contracts/useSimulateContract",draft:!1,tags:[],version:"current",frontMatter:{title:"The `useSimulateContract` hook",description:"Improve your user experience with the `useSimulateContract` hook.",hide_table_of_contents:!1},sidebar:"docs",previous:{title:"The `useWriteContract` hook",permalink:"/base-camp/docs/writing-to-contracts/useWriteContract"},next:{title:"Exercise Contracts",permalink:"/base-camp/docs/exercise-contracts"}},s={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Refining the Claim Component",id:"refining-the-claim-component",level:2},{value:"Using <code>useSimulateContract</code>",id:"using-usesimulatecontract",level:3},{value:"Making Adjustments",id:"making-adjustments",level:3},{value:"Conclusion",id:"conclusion",level:2}],u={toc:c},p="wrapper";function m(e){let{components:t,...n}=e;return(0,r.yg)(p,(0,a.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"The ",(0,r.yg)("a",{parentName:"p",href:"https://wagmi.sh/react/hooks/useSimulateContract"},(0,r.yg)("inlineCode",{parentName:"a"},"useSimulateContract"))," hook simulates and validates a contract interaction without actually sending a transaction to the blockchain. Using it allows you to detect and respond to potential errors before the user tries to send a transaction."),(0,r.yg)("hr",null),(0,r.yg)("h2",{id:"objectives"},"Objectives"),(0,r.yg)("p",null,"By the end of this guide you should be able to:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Implement wagmi's ",(0,r.yg)("inlineCode",{parentName:"li"},"useSimulateContract")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"useWriteContract")," to send transactions to a smart contract"),(0,r.yg)("li",{parentName:"ul"},"Configure the options in ",(0,r.yg)("inlineCode",{parentName:"li"},"useSimulateContract")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"useWriteContract")),(0,r.yg)("li",{parentName:"ul"},"Call a smart contract function on-demand using the write function from ",(0,r.yg)("inlineCode",{parentName:"li"},"useWriteContract"),", with arguments and a value")),(0,r.yg)("hr",null),(0,r.yg)("h2",{id:"refining-the-claim-component"},"Refining the Claim Component"),(0,r.yg)("p",null,"In the previous step-by-step, you used ",(0,r.yg)("a",{parentName:"p",href:"https://wagmi.sh/react/hooks/useWriteContract"},(0,r.yg)("inlineCode",{parentName:"a"},"useWriteContract"))," to set up a hook you can use to to call the ",(0,r.yg)("inlineCode",{parentName:"p"},"claim")," function in your smart contract when the user clicks a button. The component works well enough, but it can take a long time for the wallet to pop up, particularly if there is network congestion. You also have no way of responding to a problem with the transaction inputs until after the user tries to initiate a transaction."),(0,r.yg)("h3",{id:"using-usesimulatecontract"},"Using ",(0,r.yg)("inlineCode",{parentName:"h3"},"useSimulateContract")),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"useSimulateContract")," can be used in partnership with ",(0,r.yg)("inlineCode",{parentName:"p"},"useWriteContract"),". To do so, you set up the transaction parameters in ",(0,r.yg)("inlineCode",{parentName:"p"},"useSimulateContract"),", then use the ",(0,r.yg)("inlineCode",{parentName:"p"},"data?.request")," returned by it as an argument in the call to write to the contract. Modify your ",(0,r.yg)("inlineCode",{parentName:"p"},"TokenInfo")," component to test it:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},"// Bad code for example.  See below for fix.\nconst {\n  data: claimData,\n  isFetching: claimIsFetching,\n  isError: claimIsError,\n} = useSimulateContract({\n  address: contractData.address as `0x${string}`,\n  abi: contractData.abi,\n  functionName: 'claim',\n});\n\nuseEffect(() => {\n  if (claimIsError) {\n    alert('Unable to claim'); // TODO: Better error handling\n  }\n}, [claimIsError]);\n\n// No changes to `useWriteContract`\nconst { writeContract: claim, isPending: claimIsPending } = useWriteContract();\n\n// Other code...\n\n// Update the call to `claim`\nconst handleClaimClick = () => {\n  claim(claimData?.request);\n};\n")),(0,r.yg)("p",null,"You'll also need to update your handler to use the TypeScript pre-check feature, because the claim function will be briefly ",(0,r.yg)("inlineCode",{parentName:"p"},"undefined"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},"const handleClaimClick = () => {\n  claim(claimData!.request);\n};\n")),(0,r.yg)("p",null,"Reload the site and observe that the ",(0,r.yg)("inlineCode",{parentName:"p"},"alert")," is triggered on load if you're signed in with an address that has already claimed tokens. You'll also see that the button is disabled, as though the user had clicked it and a transaction is loading in the wallet."),(0,r.yg)("h3",{id:"making-adjustments"},"Making Adjustments"),(0,r.yg)("p",null,"The reason for this is a subtle difference in how ",(0,r.yg)("inlineCode",{parentName:"p"},"useWriteContract")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"useSimulateContract")," work."),(0,r.yg)("p",null,"In the last step-by-step, you saw how viem runs a simulation of the transaction when the ",(0,r.yg)("inlineCode",{parentName:"p"},"write")," function is called. ",(0,r.yg)("inlineCode",{parentName:"p"},"useSimulateContract")," eagerly runs this simulation and updates it's variables."),(0,r.yg)("p",null,"You'll need to make some modifications for it to work. The ",(0,r.yg)("inlineCode",{parentName:"p"},"claimIsError")," variable is being triggered when the data for the call is ",(0,r.yg)("strong",{parentName:"p"},"simulated"),", not when the call has settled. As a result, it immediately generates the error, and triggers the ",(0,r.yg)("inlineCode",{parentName:"p"},"alert")," without requiring the user to click the button."),(0,r.yg)("p",null,"You can solve this a number of ways, including simply not rendering the button if the user has already claimed. You could also modify the code, and combine it with ",(0,r.yg)("inlineCode",{parentName:"p"},"isError"),", to share this information to the user."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-tsx"},"const {\n  data: claimData,\n  isFetching: claimIsFetching,\n  isError: claimIsError,\n} = useSimulateContract({\n  address: contractData.address as `0x${string}`,\n  abi: contractData.abi,\n  functionName: 'claim',\n});\n\n// Deleted `useEffect` for `claimIsError`\n\nconst { writeContract: claim, isPending: claimIsPending } = useWriteContract();\n\n// Other code\n\nreturn (\n  <div>\n    <p>{claimIsFetching.toString()}</p>\n    <p>{'Token Balance: ' + tokenBalance}</p>\n    <button disabled={claimIsPending || claimIsError} onClick={handleClaimClick}>\n      {claimIsPending ? 'Complete In Wallet' : 'Claim Tokens'}\n    </button>\n    <p>{claimIsError ? 'Unable to claim tokens.' : 'Claim your tokens!'} </p>\n  </div>\n);\n")),(0,r.yg)("hr",null),(0,r.yg)("h2",{id:"conclusion"},"Conclusion"),(0,r.yg)("p",null,"In this step-by-step, you updated your app to use the ",(0,r.yg)("inlineCode",{parentName:"p"},"useSimulateContract")," hook to provide a speedier wallet interaction for your users. You've also learned how you can predict and respond to potential errors without the user needing to attempt to send a transaction. You could use this functionality to let them know a username is already taken, a bid amount is not large enough, or an item is no longer available."),(0,r.yg)("hr",null))}m.isMDXComponent=!0}}]);