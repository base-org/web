"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[3724],{82247:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>m});var a=n(14041);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(n),d=o,m=p["".concat(c,".").concat(d)]||p[d]||h[d]||r;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},65808:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(89575),o=(n(14041),n(82247));const r={title:"The `useWriteContract` hook",description:"Write to your smart contracts with the `useWriteContract` hook.",hide_table_of_contents:!1},i=void 0,s={unversionedId:"docs/writing-to-contracts/useWriteContract",id:"docs/writing-to-contracts/useWriteContract",title:"The `useWriteContract` hook",description:"Write to your smart contracts with the `useWriteContract` hook.",source:"@site/base-camp/docs/writing-to-contracts/useWriteContract.md",sourceDirName:"docs/writing-to-contracts",slug:"/docs/writing-to-contracts/useWriteContract",permalink:"/base-camp/docs/writing-to-contracts/useWriteContract",draft:!1,tags:[],version:"current",frontMatter:{title:"The `useWriteContract` hook",description:"Write to your smart contracts with the `useWriteContract` hook.",hide_table_of_contents:!1},sidebar:"docs",previous:{title:"Configuring `useReadContract`",permalink:"/base-camp/docs/reading-and-displaying-data/configuring-useReadContract"},next:{title:"The `useSimulateContract` hook",permalink:"/base-camp/docs/writing-to-contracts/useSimulateContract"}},c={},l=[{value:"Objectives",id:"objectives",level:2},{value:"Sending a Transaction to the Blockchain",id:"sending-a-transaction-to-the-blockchain",level:2},{value:"Setting up the Component",id:"setting-up-the-component",level:3},{value:"Reading the Token Balance",id:"reading-the-token-balance",level:3},{value:"Setting up <code>useWriteContract</code>",id:"setting-up-usewritecontract",level:3},{value:"Conclusion",id:"conclusion",level:2}],u={toc:l},p="wrapper";function h(e){let{components:t,...n}=e;return(0,o.yg)(p,(0,a.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"The ",(0,o.yg)("a",{parentName:"p",href:"https://wagmi.sh/react/hooks/useWriteContract"},(0,o.yg)("inlineCode",{parentName:"a"},"useWriteContract"))," hook allows you to call your ",(0,o.yg)("inlineCode",{parentName:"p"},"public")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"external")," smart contract functions that write to state and create a permanent modification to the data on chain."),(0,o.yg)("hr",null),(0,o.yg)("h2",{id:"objectives"},"Objectives"),(0,o.yg)("p",null,"By the end of this guide you should be able to:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Implement wagmi's ",(0,o.yg)("inlineCode",{parentName:"li"},"useWriteContract")," hook to send transactions to a smart contract"),(0,o.yg)("li",{parentName:"ul"},"Configure the options in ",(0,o.yg)("inlineCode",{parentName:"li"},"useWriteContract")),(0,o.yg)("li",{parentName:"ul"},"Display the execution, success, or failure of a function with button state changes, and data display")),(0,o.yg)("hr",null),(0,o.yg)("h2",{id:"sending-a-transaction-to-the-blockchain"},"Sending a Transaction to the Blockchain"),(0,o.yg)("admonition",{type:"warning"},(0,o.yg)("p",{parentName:"admonition"},"In this step-by-step, you're going to start with the ",(0,o.yg)("a",{parentName:"p",href:"https://wagmi.sh/react/hooks/useWriteContract"},(0,o.yg)("inlineCode",{parentName:"a"},"useWriteContract"))," hook. You probably won't want to use this method in production. In the next step-by-step, we'll show you the ","[",(0,o.yg)("inlineCode",{parentName:"p"},"useSimulateContract"),"]"," hook, how it works with ",(0,o.yg)("inlineCode",{parentName:"p"},"useWriteContract"),", and how you can use it to create a better user experience."),(0,o.yg)("p",{parentName:"admonition"},"Exploring them separately will highlight the functionality provided by the prepare hook.")),(0,o.yg)("admonition",{type:"caution"},(0,o.yg)("p",{parentName:"admonition"},"In this module, you'll'll extend the onchain app you build in the previous module, ",(0,o.yg)("a",{parentName:"p",href:"../reading-and-displaying-data/useAccount"},"Reading and Displaying Data"),".")),(0,o.yg)("p",null,"You've built an app that can read from your Simple DAO smart contract, but so far, you've used BaseScan to send transactions that call your write functions. You can use the ",(0,o.yg)("a",{parentName:"p",href:"https://wagmi.sh/react/hooks/useWriteContract"},(0,o.yg)("inlineCode",{parentName:"a"},"useWriteContract"))," hook in a similar way to call those functions directly from your app."),(0,o.yg)("h3",{id:"setting-up-the-component"},"Setting up the Component"),(0,o.yg)("p",null,"Add a new component called ",(0,o.yg)("inlineCode",{parentName:"p"},"TokenInfo")," to the project, and a state variable for ",(0,o.yg)("inlineCode",{parentName:"p"},"tokenBalance"),"."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},"import { useState } from 'react';\n\nexport function TokenInfo() {\n  const [tokenBalance, setTokenBalance] = useState(0);\n}\n")),(0,o.yg)("h3",{id:"reading-the-token-balance"},"Reading the Token Balance"),(0,o.yg)("p",null,"You'll need to know how many tokens the user has to be able to make decisions on what UI controls to display, so start by adding a ",(0,o.yg)("inlineCode",{parentName:"p"},"useReadContract"),". You don't have a function for this directly in your contract, but your contract inherits from the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol"},"OpenZeppelin ERC20")," contract, which has a function called ",(0,o.yg)("inlineCode",{parentName:"p"},"balanceOf")," that takes an address and returns the balance for that address."),(0,o.yg)("p",null,"You'll need the user's address to use in ",(0,o.yg)("inlineCode",{parentName:"p"},"args"),", which you can conveniently get from the ",(0,o.yg)("a",{parentName:"p",href:"https://wagmi.sh/react/hooks/useAccount"},(0,o.yg)("inlineCode",{parentName:"a"},"useAccount"))," hook using the pattern below."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx:"},'const { data: balanceData, queryKey: balanceQueryKey } =\n  useReadContract({\n    address: contractData.address as `0x${string}`,\n    abi: contractData.abi,\n    functionName: "balanceOf",\n    args: [useAccount().address],\n  });\n\nuseEffect(() => {\n  if (balanceData) {\n    setTokenBalance(balanceData as number);\n  }\n}, [balanceData]);\n\nuseEffect(() => {\n  queryClient.invalidateQueries({ queryKey: balanceQueryKey });\n}, [blockNumber, queryClient]);\n')),(0,o.yg)("admonition",{type:"caution"},(0,o.yg)("p",{parentName:"admonition"},"Remember, this is an expensive method to watch for data to change on the blockchain. In this case, a more production-suitable solution might be to call ",(0,o.yg)("inlineCode",{parentName:"p"},"balanceOf")," after the user has done something that might change the balance.")),(0,o.yg)("p",null,"Set the ",(0,o.yg)("inlineCode",{parentName:"p"},"return")," for your component to display this balance to the user:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},"return (\n  <div>\n    <p>{'Token Balance: ' + tokenBalance}</p>\n  </div>\n);\n")),(0,o.yg)("p",null,"Then, add the component to your app in ",(0,o.yg)("inlineCode",{parentName:"p"},"index.tsx"),"."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},"return (\n  <div className={styles.container}>\n    <main className={styles.main}>\n      <ConnectButton />\n      <ConnectionWindow />\n      <TokenInfo />\n      <IssueList />\n    </main>\n);\n")),(0,o.yg)("p",null,"Run the app and make sure you see the expected balance displayed on the page."),(0,o.yg)("h3",{id:"setting-up-usewritecontract"},"Setting up ",(0,o.yg)("inlineCode",{parentName:"h3"},"useWriteContract")),(0,o.yg)("p",null,"The ",(0,o.yg)("a",{parentName:"p",href:"https://wagmi.sh/react/hooks/useWriteContract"},(0,o.yg)("inlineCode",{parentName:"a"},"useWriteContract"))," hook is configured similarly to the ",(0,o.yg)("a",{parentName:"p",href:"https://wagmi.sh/react/hooks/useReadContract"},(0,o.yg)("inlineCode",{parentName:"a"},"useReadContract"))," hook, with one important difference. You'll need to decompose the ",(0,o.yg)("inlineCode",{parentName:"p"},"write")," property from the function call. This is a function that you can use to call your smart contract function whenever you'd like!"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},"const { writeContract: claim, isPending: claimIsPending } = useWriteContract();\n")),(0,o.yg)("p",null,"Add an event handler function and a button. As with the ",(0,o.yg)("inlineCode",{parentName:"p"},"useReadContract")," hook, you can use ",(0,o.yg)("inlineCode",{parentName:"p"},"isPending")," and other state helpers to adjust your UI. The name of this one is a little misleading. ",(0,o.yg)("inlineCode",{parentName:"p"},"isPending")," will be ",(0,o.yg)("inlineCode",{parentName:"p"},"true")," starting from the moment the transaction gets sent to the user's wallet."),(0,o.yg)("p",null,"You can use this to nudge them to look to their wallet to complete the transaction. Additionally, add a ",(0,o.yg)("inlineCode",{parentName:"p"},"useEffect")," to watch for an error state."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-tsx"},"const handleClaimClick = () => {\n  claim({\n    abi: contractData.abi,\n    address: contractData.address as `0x${string}`,\n    functionName: 'claim',\n  });\n};\n\nreturn (\n  <div>\n    <p>{'Token Balance: ' + tokenBalance}</p>\n    <button disabled={claimIsLoading} onClick={handleClaimClick}>\n      {claimIsLoading ? 'Complete In Wallet' : 'Claim Tokens'}\n    </button>\n  </div>\n);\n")),(0,o.yg)("p",null,"Try it out. Notice that the button text briefly changes without the wallet window popping up if you click the ",(0,o.yg)("inlineCode",{parentName:"p"},"Claim Tokens")," button while connected with a wallet that already owns the tokens. The reason this happens is that viem, which underlies wagmi, runs a simulation of the transaction to estimate gas costs. If that simulation fails, it triggers the fail mechanism immediately, rather than allowing the app to send a bad transaction to the blockchain and cost the user gas for a call doomed to fail. You will fix this in the next tutorial."),(0,o.yg)("p",null,"In the meantime, you'll need to change to a new wallet or redeploy your contract a couple of times to complete your testing. Do that, and try out the call on a wallet that hasn't claimed any tokens. Notice that the button is disabled and the text now prompts the user to look to their wallet to approve the transaction."),(0,o.yg)("hr",null),(0,o.yg)("h2",{id:"conclusion"},"Conclusion"),(0,o.yg)("p",null,"In this step-by-step, you've learned how to use the ",(0,o.yg)("a",{parentName:"p",href:"https://wagmi.sh/react/hooks/useWriteContract"},(0,o.yg)("inlineCode",{parentName:"a"},"useWriteContract"))," hook to call your smart contract functions on demand. You've also tested methods to manage the UI/UX experience for your users, based on the state of the transaction, as well as its success or failure."),(0,o.yg)("hr",null))}h.isMDXComponent=!0}}]);