---
title: The `useAccount` Hook
description: Learn how to access information about the connected user's wallet.
hide_table_of_contents: false
---

[wagmi] is a library that provides React hooks that trade a somewhat complex setup process for a great developer experience when building a frontend around the constraints and quirks of onchain building. One of the hooks, `useAccount`, provides access to information about your users' wallet and connection information.

You can use this for connection-status-based rendering, to enable or disable controls or views based on address, and many other useful tasks.

:::caution

The frontend tutorials are currently based on version 1.X of Wagmi. Version 2 has recently been released and is a near complete rewrite of the library. We are working on updates. In the meantime, please use Version 1, or review the [migration guide](https://wagmi.sh/react/guides/migrate-from-v1-to-v2).

:::

---

## Objectives

By the end of this guide you should be able to:

- Implement the `useAccount`` hook to show the user's address, connection state, network, and balance
- Implement an `isMounted` hook to prevent hydration errors

---

## Displaying Connection Information

We'll be working from an app generated by RainbowKit's [quick start]. Either open the one you created when we were exploring [Wallet Connectors], or create a new one for this project.

Either way, change the list of chains to only include `baseSepolia` as the network option. You don't want to accidentally spend real money while developing!

```typescript
const { chains, publicClient, webSocketPublicClient } = configureChains(
  [baseSepolia],
  [
    // other providers...
    publicProvider(),
  ],
);
```

### The `useAccount` Hook

The [`useAccount`] hook allows you to access account and connection data from within any of your components.

Add a folder for `components` and a file called `ConnectionWindow.tsx` in that folder. Add the below component to the file, and replace the boilerplate text in `index.tsx` with an instance of it.

```typescript
// ConnectionWindow.tsx
export function ConnectionWindow() {
  return (
    <div>
      <p>Connection Status</p>
    </div>
  );
}
```

```typescript
// index.tsx
import { ConnectButton } from '@rainbow-me/rainbowkit';
import type { NextPage } from 'next';
import Head from 'next/head';
import styles from '../styles/Home.module.css';
import { ConnectionWindow } from '../components/ConnectionWindow';

const Home: NextPage = () => {
  return (
    <div className={styles.container}>
      <main className={styles.main}>
        <ConnectButton />
        <ConnectionWindow />
      </main>
    </div>
  );
};

export default Home;
```

For the purposes of this exercise, open `styles/Home.module.css` and **delete or comment out** `.main`. Doing so will move the content to the top of the page, which will prevent the RainbowKit modal from blocking our ability to see changes.

Return to `ConnectionWindow.tsx` and add the `useAccount` hook to the top, where you'd add any state variables. The general pattern for wagmi hooks is you decompose the properties you want to use from a function call of the name of the hook. For some, you'll add a config object to that call, but it's not needed for this one.

```typescript
import { useAccount } from 'wagmi';

export function ConnectionWindow() {
  const { address, isConnected, isConnecting, isDisconnected } = useAccount();

  return (
    <div>
      <h2>Connection Status</h2>
    </div>
  );
}
```

You can see all the options in the docs:

```typescript
{
  address?: string
  connector?: Connector
  isConnecting: boolean
  isReconnecting: boolean
  isConnected: boolean
  isDisconnected: boolean
  status: 'connecting' | 'reconnecting' | 'connected' | 'disconnected'
}
```

Update your `<div>` to show the address of the connected wallet:

```Typescript
<div>
  <h2>Connection Status</h2>
  <div>
    <p>{"Address: " + address}</p>
  </div>
</div>
```

Test it out by connecting and disconnecting with your wallet. You should see your full address when you are connected, and the address will be `undefined` when you are disconnected.

### Connection Status Conditional Rendering

It isn't very nice to display a value of `undefined` to the user, so let's use the connection status values for conditional rendering depending on if the user is disconnected, connected, or connecting.

A common pattern is to use the conditional directly in the html return of a component or render function. For example, we could add a line to show that we're connecting as demonstrated:

```
<div>
  <h2>Connection Information</h2>
  <div>
    {isConnecting && <p>Please click Connect in your wallet...</p>}
    <p>{"Address: " + address}</p>
  </div>
</div>
```

You're going to get an `Unhandled Runtime Error`. You can safely close the error window and ignore it for now, we'll fix it in a moment.

Connect and disconnect your wallet a few times. The `isConnecting` state is true while the _Connect to website_ wallet UI is open.

Use the `connected` property in the same way to only render the wallet address if there is a wallet connected. Similarly, use the `isDisconnected` property to show a message asking the user to connect.

```
<div>
  <h2>Connection Information</h2>
  <div>
    {isConnecting && <p>Please click Connect in your wallet...</p>}
    {isConnected && <p>{"Address: " + address}</p>}
    {isDisconnected && <p>Please connect your wallet to use this app.</p>}
  </div>
</div>
```

### Implementing the `useIsMounted` Hook

Whenever you refresh your browser window, you've probably seen an `Unhandled Runtime Error` that content did not match. The error provides a link explaining why this [hydration error] occurred, but doesn't give you much to explain why the error is occurring here.

What's happening is an interaction between the server-side rendering of Next.js, and wagmi's use of local storage caching to prevent a flickering of UI elements that can occur when connection state changes. As a result, the server and the client have different states for the first render cycle.

You can fix this by adding a small hook to make sure the component is mounted before it tries to render the app.

Open `_app.tsx` and import `useEffect` and `useState` from `'react'`.

Create a state variable called `mounted`, and set it in the first render cycle to be `true`. Finally, use the same conditional rendering technique to only render the `<Component {...pageProps} />` element if the app has mounted.

<details>

<summary>Reveal code</summary>


```typescript
const [mounted, setMounted] = useState(false);
useEffect(() => setMounted(true), []);

return (
  <WagmiConfig config={wagmiConfig}>
    <RainbowKitProvider chains={chains}>
      {mounted && <Component {...pageProps} />}
    </RainbowKitProvider>
  </WagmiConfig>
);
```

</details>

<br/>

With this fix in place, you should no longer get hydration errors!

---

## Conclusion

In this guide, you've learned how the `useAccount` hook gives you access to information about the user's connection status and wallet. It can be used in any part of your app that is wrapped by the wagmi context provider. You've also learned a technique for conditional rendering based on connection status. Finally, you've learned how the underlying mechanics of wagmi and Next.js conflict, and what you can do to resolve the resulting hydration error.

---

[RainbowKit]: https://www.rainbowkit.com/
[wagmi]: https://wagmi.sh/
[quick start]: https://www.rainbowkit.com/docs/installation/
[Wallet Connectors]: ../frontend-setup/wallet-connectors/
[`useAccount`]: https://wagmi.sh/react/hooks/useAccount
[hydration error]: https://nextjs.org/docs/messages/react-hydration-error
