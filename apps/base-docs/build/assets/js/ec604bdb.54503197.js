"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[6989],{30876:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(2784);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=o,h=c["".concat(l,".").concat(m)]||c[m]||u[m]||i;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},63297:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7896),o=(n(2784),n(30876));const i={title:"Basic Types",description:"Introduction to basic types in Solidity.",hide_table_of_contents:!1},r=void 0,s={unversionedId:"docs/contracts-and-basic-functions/basic-types",id:"docs/contracts-and-basic-functions/basic-types",title:"Basic Types",description:"Introduction to basic types in Solidity.",source:"@site/base-camp/docs/contracts-and-basic-functions/basic-types.md",sourceDirName:"docs/contracts-and-basic-functions",slug:"/docs/contracts-and-basic-functions/basic-types",permalink:"/base-camp/docs/contracts-and-basic-functions/basic-types",draft:!1,tags:[],version:"current",frontMatter:{title:"Basic Types",description:"Introduction to basic types in Solidity.",hide_table_of_contents:!1},sidebar:"docs",previous:{title:"Hello World",permalink:"/base-camp/docs/contracts-and-basic-functions/hello-world-step-by-step"},next:{title:"Basic Functions Exercise",permalink:"/base-camp/docs/contracts-and-basic-functions/basic-functions-exercise"}},l={},p=[{value:"Objectives",id:"objectives",level:2},{value:"Common Properties",id:"common-properties",level:2},{value:"Boolean",id:"boolean",level:2},{value:"Logical Operators",id:"logical-operators",level:3},{value:"Numbers",id:"numbers",level:2},{value:"Min, Max, and Overflow",id:"min-max-and-overflow",level:3},{value:"<code>uint</code> vs. <code>int</code>",id:"uint-vs-int",level:3},{value:"Integer Variants",id:"integer-variants",level:3},{value:"Operators",id:"operators",level:3},{value:"Addresses",id:"addresses",level:2},{value:"Members of Addresses",id:"members-of-addresses",level:3},{value:"Contracts",id:"contracts",level:2},{value:"Byte Arrays and Strings",id:"byte-arrays-and-strings",level:2},{value:"Strings",id:"strings",level:3},{value:"Enums",id:"enums",level:2},{value:"Constant and Immutable",id:"constant-and-immutable",level:2},{value:"Constant",id:"constant",level:3},{value:"Immutable",id:"immutable",level:3},{value:"Conclusion",id:"conclusion",level:2}],d={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Solidity contains most of the basic ",(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/types.html"},"types")," you are used to from other languages, but their properties and usage are often a little different than other languages and are likely much more restrictive. In particular, Solidity is a very ",(0,o.kt)("strong",{parentName:"p"},"explicit")," language and will not allow you to make inferences most of the time."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"objectives"},"Objectives"),(0,o.kt)("p",null,"By the end of this lesson you should be able to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Categorize basic data types"),(0,o.kt)("li",{parentName:"ul"},"List the major differences between data types in Solidity as compared to other languages"),(0,o.kt)("li",{parentName:"ul"},"Compare and contrast signed and unsigned integers")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"common-properties"},"Common Properties"),(0,o.kt)("p",null,"In Solidity, ",(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/types.html"},"types")," must always have a value and are never ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"none"),". Because of this, each type has a default value. If you declare a variable without assigning a value, it will instead have the default value for that type. This property can lead to some tricky bugs until you get used to it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"uint defaultValue;\nuint explicitValue = 0;\n\n// (defaultValue == explicitValue) <-- true\n")),(0,o.kt)("p",null,"Types can be cast from one type to another, but not as freely as you may expect. For example, to convert a ",(0,o.kt)("inlineCode",{parentName:"p"},"uint256")," into a ",(0,o.kt)("inlineCode",{parentName:"p"},"int8"),", you need to cast twice:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 first = 1;\nint8 second = int8(int256(first));\n")),(0,o.kt)("admonition",{type:"danger"},(0,o.kt)("p",{parentName:"admonition"},"Overflow/underflow protection (described below), does not provide protection when casting."),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"uint256 first = 256;\nint8 second = int8(int256(first)); // <- The value stored in second is 0\n"))),(0,o.kt)("h2",{id:"boolean"},"Boolean"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/types.html#booleans"},"Booleans")," can have a value of ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),". Solidity does not have the concept of ",(0,o.kt)("em",{parentName:"p"},"truthy")," or ",(0,o.kt)("em",{parentName:"p"},"falsey"),", and non-boolean values cannot be cast to bools by design. The short conversation in this ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ethereum/solidity/issues/1200"},"issue")," explains why, and explains the philosophy why."),(0,o.kt)("h3",{id:"logical-operators"},"Logical Operators"),(0,o.kt)("p",null,"Standard logical operators (",(0,o.kt)("inlineCode",{parentName:"p"},"!"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"&&"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"||"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"=="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"!="),") apply to booleans. Short-circuiting rules do apply, which can sometimes be used for gas savings since if the first operator in an ",(0,o.kt)("inlineCode",{parentName:"p"},"&&")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"||")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),", the second will not be evaluated. For example, the following code will execute without an error, despite the divide by zero in the second statement."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"// Bad code for example.  Do not use.\nuint divisor = 0;\nif(1 < 2 || 1 / divisor > 0) {\n    // Do something...\n}\n")),(0,o.kt)("p",null,"You cannot use any variant of ",(0,o.kt)("inlineCode",{parentName:"p"},">")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"<")," with booleans, because they cannot be implicitly or explicitly cast to a type that uses those operators."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"numbers"},"Numbers"),(0,o.kt)("p",null,"Solidity has a number of types for signed and unsigned ",(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/types.html#integers"},"integers"),", which are not ignored as much as they are in other languages, due to potential gas-savings when storing smaller numbers. Support for ",(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/types.html#fixed-point-numbers"},"fixed point numbers")," is under development, but is not fully implemented as of version ",(0,o.kt)("inlineCode",{parentName:"p"},"0.8.17"),"."),(0,o.kt)("p",null,"Floating point numbers are not supported and are not likely to be. Floating precision includes an inherent element of ambiguity that doesn't work for explicit environments like blockchains."),(0,o.kt)("h3",{id:"min-max-and-overflow"},"Min, Max, and Overflow"),(0,o.kt)("p",null,"Minimum and maximum values for each type can be accessed with ",(0,o.kt)("inlineCode",{parentName:"p"},"type(<type>).min")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"type(<type>).max"),". For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"type(uint).min")," is ",(0,o.kt)("strong",{parentName:"p"},"0"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"type(uint).max")," is equal to ",(0,o.kt)("strong",{parentName:"p"},"2^256-1"),"."),(0,o.kt)("p",null,"An overflow or underflow will cause a transaction to ",(0,o.kt)("em",{parentName:"p"},"revert"),", unless it occurs in a code block that is marked as ",(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/control-structures.html#unchecked"},"unchecked"),"."),(0,o.kt)("h3",{id:"uint-vs-int"},(0,o.kt)("inlineCode",{parentName:"h3"},"uint")," vs. ",(0,o.kt)("inlineCode",{parentName:"h3"},"int")),(0,o.kt)("p",null,"In Solidity, it is common practice to favor ",(0,o.kt)("inlineCode",{parentName:"p"},"uint")," over ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," when it is known that a value will never (or should never) be below zero. This practice helps you write more secure code by requiring you to declare whether or not a given value should be allowed to be negative. Use ",(0,o.kt)("inlineCode",{parentName:"p"},"uint")," for values that should not, such as array indexes, account balances, etc. and ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," for a value that does ",(0,o.kt)("strong",{parentName:"p"},"need")," to be negative."),(0,o.kt)("h3",{id:"integer-variants"},"Integer Variants"),(0,o.kt)("p",null,"Smaller and larger variants of integers exist in many languages but have fallen out of favor in many instances, in part because memory and storage are relatively cheap. Solidity supports sizes in steps of eight from ",(0,o.kt)("inlineCode",{parentName:"p"},"uint8")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"uint256"),", and the same for ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,o.kt)("p",null,"Smaller sized integers are used to optimize gas usage in storage operations, but there is a cost. The EVM operates with 256 bit words, so operations involving smaller data types must be cast first, which costs gas."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"uint")," is an alias for ",(0,o.kt)("inlineCode",{parentName:"p"},"uint256")," and can be considered the default."),(0,o.kt)("h3",{id:"operators"},"Operators"),(0,o.kt)("p",null,"Comparisons (",(0,o.kt)("inlineCode",{parentName:"p"},"<="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"=="),", ",(0,o.kt)("inlineCode",{parentName:"p"},"!="),", ",(0,o.kt)("inlineCode",{parentName:"p"},">="),", ",(0,o.kt)("inlineCode",{parentName:"p"},">"),") and arithmetic (",(0,o.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"/"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"%"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"**"),") operators are present and work as expected. You can also use bit and shift operators."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"uint")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," variants can be compared directly, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"uint8")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"uint256"),", but you must cast one value to compare a ",(0,o.kt)("inlineCode",{parentName:"p"},"uint")," to an ",(0,o.kt)("inlineCode",{parentName:"p"},"int"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"uint first = 1;\nint8 second = 1;\n\nif(first == uint8(second)) {\n    // Do something...\n}\n")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"addresses"},"Addresses"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/types.html#address"},"address")," type is a relatively unique type representing a wallet or contract address. It holds a 20-byte value, similar to the one we explored when you deployed your ",(0,o.kt)("em",{parentName:"p"},"Hello World")," contract in ",(0,o.kt)("em",{parentName:"p"},"Remix"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"address payable")," is a variant of ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," that allows you to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"send")," methods. This distinction helps prevent sending Ether, or other tokens, to a contract that is not designed to receive it. If that were to happen, the Ether would be lost."),(0,o.kt)("p",null,"Addresses are ",(0,o.kt)("strong",{parentName:"p"},"not")," strings and do not need quotes when represented literally, but conversions from ",(0,o.kt)("inlineCode",{parentName:"p"},"bytes20")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"uint160")," are allowed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"address existingWallet = 0xd9145CCE52D386f254917e481eB44e9943F39138;\n")),(0,o.kt)("h3",{id:"members-of-addresses"},"Members of Addresses"),(0,o.kt)("p",null,"Addresses contain a number of functions. ",(0,o.kt)("inlineCode",{parentName:"p"},"balance")," returns the balance of an address, and ",(0,o.kt)("inlineCode",{parentName:"p"},"transfer"),", mentioned above, can be used to send ",(0,o.kt)("inlineCode",{parentName:"p"},"ether"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"function getBalance(address _address) public view returns(uint) {\n    return _address.balance;\n}\n")),(0,o.kt)("p",null,"Later on, you'll learn about ",(0,o.kt)("inlineCode",{parentName:"p"},"call"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"delegatecall"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"staticcall"),", which can be used to call functions deployed in other contracts."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"contracts"},"Contracts"),(0,o.kt)("p",null,"When you declare a ",(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/types.html#contract-types"},"contract"),", you are defining a type. This type can be used to instantiate one contract as a local variable inside a second contract, allowing the second to interact with the first."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"byte-arrays-and-strings"},"Byte Arrays and Strings"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/types.html#fixed-size-byte-arrays"},"Byte arrays")," come as both fixed-size and dynamically-sized. They hold a sequence of bytes. Arrays are a little more complicated than in other languages and will be covered in-depth later."),(0,o.kt)("h3",{id:"strings"},"Strings"),(0,o.kt)("p",null,"Strings are arrays in Solidity, not a type. You cannot concat them with ",(0,o.kt)("inlineCode",{parentName:"p"},"+"),", but as of ",(0,o.kt)("em",{parentName:"p"},"0.8.12"),", you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"string.concat(first, second)"),". They are limited to printable characters and escaped characters. Casting other data types to ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," is at best tricky, and sometimes impossible."),(0,o.kt)("p",null,"Generally speaking, you should be deliberate when working with strings inside of a smart contract. Don't be afraid to use them when appropriate, but if possible, craft and display messages on the front end rather than spending gas to assemble them on the back end."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"enums"},"Enums"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/types.html#enums"},"Enums")," allow you to apply human-readable labels to a list of unsigned integers."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"enum Flavors { Vanilla, Chocolate, Strawberry, Coffee }\n\nFlavors chosenFlavor = Flavors.Coffee;\n")),(0,o.kt)("p",null,"Enums can be explicitly cast to and from ",(0,o.kt)("inlineCode",{parentName:"p"},"uint"),", but not implicitly. They are limited to 256 members."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"constant-and-immutable"},"Constant and Immutable"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/contracts.html?constant-and-immutable-state-variables#constant-and-immutable-state-variables"},"constant and immutable")," keywords allow you to declare variables that cannot be changed. Both result in gas savings because the compiler does not need to reserve a storage slot for these values."),(0,o.kt)("p",null,"As of ",(0,o.kt)("em",{parentName:"p"},"0.8.17"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"constant")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"immutable")," are not fully implemented. Both are supported on ",(0,o.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/types.html#value-types"},"value types"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"constant")," can also be used with strings."),(0,o.kt)("h3",{id:"constant"},"Constant"),(0,o.kt)("p",null,"Constants can be declared at the file level, or at the contract level. In Solidity, modifiers come after the type declaration. You must initialize a value when declaring a constant. Convention is to use SCREAMING_SNAKE_CASE for constants."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"uint constant NUMBER_OF_TEAMS = 10;\n\ncontract Cars {\n    uint constant NUMBER_OF_CARS = 20;\n}\n")),(0,o.kt)("p",null,"At compilation, the compiler replaces every instance of the constant variable with its literal value."),(0,o.kt)("h3",{id:"immutable"},"Immutable"),(0,o.kt)("p",null,"The immutable keyword is used to declare variables that are set once within the constructor, which are then never changed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"contract Season {\n    immutable numberOfRaces;\n\n    constructor(uint _numberOfRaces) {\n        numberOfRaces = _numberOfRaces;\n    }\n}\n")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"You've learned the usage and some of the unique quirks of common variable types in Solidity. You've seen how overflow and underflow are handled and how that behavior can be overridden. You've learned why unsigned integers are used more commonly than in other languages, why floats are not present, and have been introduced to some of the quirks of working with strings. Finally, you've been introduced to the address and contract data types."),(0,o.kt)("hr",null))}u.isMDXComponent=!0}}]);