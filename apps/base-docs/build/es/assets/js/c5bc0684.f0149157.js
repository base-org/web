"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[8574],{30876:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(2784);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(a),h=o,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||r;return a?n.createElement(m,i(i({ref:t},c),{},{components:a})):n.createElement(m,i({ref:t},c))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},55716:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=a(7896),o=(a(2784),a(30876));const r={title:"Account Abstraction on Base using Privy and the Base Paymaster",slug:"/account-abstraction-with-privy-and-base-paymaster",description:"A tutorial that teaches how to implement Account Abstraction into a Base project using Privy and the Base paymaster.",author:"Brian Doyle and Aaron Hayslip",keywords:["Privy","viem","frontend","smart contract development","EVM","Next.js","Base","Base network","account abstraction","Base paymaster","embedded wallet"],tags:["account abstraction"],difficulty:"intermediate",hide_table_of_contents:!1,displayed_sidebar:null},i=void 0,s={unversionedId:"docs/account-abstraction-with-privy-and-base-paymaster",id:"docs/account-abstraction-with-privy-and-base-paymaster",title:"Account Abstraction on Base using Privy and the Base Paymaster",description:"A tutorial that teaches how to implement Account Abstraction into a Base project using Privy and the Base paymaster.",source:"@site/tutorials/docs/2_account-abstraction-with-privy-and-base-paymaster.md",sourceDirName:"docs",slug:"/account-abstraction-with-privy-and-base-paymaster",permalink:"/es/tutorials/account-abstraction-with-privy-and-base-paymaster",draft:!1,tags:[{label:"account abstraction",permalink:"/es/tutorials/tags/account-abstraction"}],version:"current",sidebarPosition:2,frontMatter:{title:"Account Abstraction on Base using Privy and the Base Paymaster",slug:"/account-abstraction-with-privy-and-base-paymaster",description:"A tutorial that teaches how to implement Account Abstraction into a Base project using Privy and the Base paymaster.",author:"Brian Doyle and Aaron Hayslip",keywords:["Privy","viem","frontend","smart contract development","EVM","Next.js","Base","Base network","account abstraction","Base paymaster","embedded wallet"],tags:["account abstraction"],difficulty:"intermediate",hide_table_of_contents:!1,displayed_sidebar:null}},l={},p=[{value:"Objectives",id:"objectives",level:2},{value:"Intro to Account Abstraction",id:"intro-to-account-abstraction",level:3},{value:"Intro to Privy",id:"intro-to-privy",level:3},{value:"Implementing the Paymaster",id:"implementing-the-paymaster",level:3},{value:"Prerequisites",id:"prerequisites",level:2},{value:"1. Be familiar with modern, frontend web development",id:"1-be-familiar-with-modern-frontend-web-development",level:3},{value:"2. Possess a general understanding of the EVM and smart contract development",id:"2-possess-a-general-understanding-of-the-evm-and-smart-contract-development",level:3},{value:"Intro do Account Abstraction",id:"intro-do-account-abstraction",level:2},{value:"The Problem Account Abstraction Solves",id:"the-problem-account-abstraction-solves",level:3},{value:"Overview of ERC-4337 - Account Abstraction",id:"overview-of-erc-4337---account-abstraction",level:3},{value:"How Account Abstraction Works",id:"how-account-abstraction-works",level:3},{value:"1. <strong>Smart Contract Wallet Creation</strong>",id:"1-smart-contract-wallet-creation",level:4},{value:"2. <strong>User Operation Creation</strong>",id:"2-user-operation-creation",level:4},{value:"3. <strong>Signature Generation</strong>:",id:"3-signature-generation",level:4},{value:"4. <strong>Alt Mempool</strong>:",id:"4-alt-mempool",level:4},{value:"5. <strong>Bundler and Operation Submission</strong>:",id:"5-bundler-and-operation-submission",level:4},{value:"6. <strong>Operation Validation</strong>:",id:"6-operation-validation",level:4},{value:"7. <strong>Operation Execution</strong>:",id:"7-operation-execution",level:4},{value:"Intro to Privy",id:"intro-to-privy-1",level:2},{value:"Overview of Privy",id:"overview-of-privy",level:3},{value:"Privy Quick Start",id:"privy-quick-start",level:3},{value:"Setup",id:"setup",level:4},{value:"Setting Your App Id",id:"setting-your-app-id",level:4},{value:"Starting the App",id:"starting-the-app",level:4},{value:"Privy Login Walkthrough",id:"privy-login-walkthrough",level:3},{value:"PrivyProvider",id:"privyprovider",level:3},{value:"The <code>usePrivy</code> Hook",id:"the-useprivy-hook",level:3},{value:"The <code>useWallets</code> Hook",id:"the-usewallets-hook",level:3},{value:"Embedded Wallets",id:"embedded-wallets",level:3},{value:"Implementing the Paymaster",id:"implementing-the-paymaster-1",level:2},{value:"Reviewing the Example",id:"reviewing-the-example",level:3},{value:"Reviewing the Transaction and Contract",id:"reviewing-the-transaction-and-contract",level:3},{value:"Tokens Transferred and the NFT Contract",id:"tokens-transferred-and-the-nft-contract",level:4},{value:"The Bundler (Transaction Sender)",id:"the-bundler-transaction-sender",level:4},{value:"EntryPoint",id:"entrypoint",level:4},{value:"Review the Example Code",id:"review-the-example-code",level:3},{value:"<code>SmartAccountContext.tsx</code>",id:"smartaccountcontexttsx",level:4},{value:"How to Call a Smart Contract Function with the Paymaster",id:"how-to-call-a-smart-contract-function-with-the-paymaster",level:4},{value:"Implementing the Paymaster in your own App",id:"implementing-the-paymaster-in-your-own-app",level:3},{value:"Copying and Updating the Source Files",id:"copying-and-updating-the-source-files",level:4},{value:"Updating to Use the User&#39;s Wallet",id:"updating-to-use-the-users-wallet",level:4},{value:"Configuring the PrivyProvider and Adding SmartAccountProvider",id:"configuring-the-privyprovider-and-adding-smartaccountprovider",level:4},{value:"Checking Progress",id:"checking-progress",level:4},{value:"Calling a Smart Contract Function",id:"calling-a-smart-contract-function",level:4},{value:"Calling Another Function",id:"calling-another-function",level:4},{value:"Conclusion",id:"conclusion",level:2}],c={toc:p},d="wrapper";function u(e){let{components:t,...r}=e;return(0,o.kt)(d,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This tutorial shows you how to use ",(0,o.kt)("a",{parentName:"p",href:"https://www.privy.dev/"},"Privy"),", ",(0,o.kt)("a",{parentName:"p",href:"https://www.alchemy.com/account-kit"},"Alchemy's Account Kit"),", and the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/base-org/paymaster"},"Base Paymaster")," to enable your users to use onchain apps without creating a wallet on their own, or even needing to pay for gas fees!"),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"objectives"},"Objectives"),(0,o.kt)("p",null,"By the end of this tutorial, you should be able to:"),(0,o.kt)("h3",{id:"intro-to-account-abstraction"},"Intro to Account Abstraction"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Explain how Account Abstraction can improve user experience for onchain apps"),(0,o.kt)("li",{parentName:"ul"},"Describe the difference between contract accounts and EOAs, the limitations of contract accounts, and how EIP-4337 uses ",(0,o.kt)("inlineCode",{parentName:"li"},"UserOperation"),"s to mitigate these limitations"),(0,o.kt)("li",{parentName:"ul"},"Outline how Account Abstraction works, and how users interact with smart contract wallets")),(0,o.kt)("h3",{id:"intro-to-privy"},"Intro to Privy"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Implement Privy's quick start to add onchain authentication to a NextJS application"),(0,o.kt)("li",{parentName:"ul"},"Compare Privy's progressive authentication strategy with traditional wallet-based authentication"),(0,o.kt)("li",{parentName:"ul"},"Use Privy's ",(0,o.kt)("inlineCode",{parentName:"li"},"PrivyProvider")," context and ",(0,o.kt)("inlineCode",{parentName:"li"},"usePrivy")," hook to implement basic authentication via an email address, SMS, EOA, and/or social auth"),(0,o.kt)("li",{parentName:"ul"},"Utilize Privy's Embedded Wallets to enable users to utilize wallet-based actions without having to connect to an external wallet or leave your application")),(0,o.kt)("h3",{id:"implementing-the-paymaster"},"Implementing the Paymaster"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Describe how a third party can use a ",(0,o.kt)("em",{parentName:"li"},"paymaster")," to sponsor gas"),(0,o.kt)("li",{parentName:"ul"},"Modify Privy's Base ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/privy-io/base-paymaster-example/blob/main/README.md"},"paymaster example")," example to work in another app, using an EOA to allow a user to call a smart contract function without requiring the user to pay any gas")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("h3",{id:"1-be-familiar-with-modern-frontend-web-development"},"1. Be familiar with modern, frontend web development"),(0,o.kt)("p",null,"In this tutorial, we'll be working with a React frontend built with ",(0,o.kt)("a",{parentName:"p",href:"https://nextjs.org/"},"Next.js"),". While you don't need to be an expert, we'll assume that you're comfortable with the basics."),(0,o.kt)("h3",{id:"2-possess-a-general-understanding-of-the-evm-and-smart-contract-development"},"2. Possess a general understanding of the EVM and smart contract development"),(0,o.kt)("p",null,"This tutorial assumes that you're reasonably comfortable writing basic smart contracts. If you're just getting started, jump over to our ",(0,o.kt)("a",{parentName:"p",href:"https://base.org/camp"},"Basecamp")," guides and start learning!"),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"intro-do-account-abstraction"},"Intro do Account Abstraction"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-4337"},"ERC-4337"),", also known as ",(0,o.kt)("em",{parentName:"p"},"Account Abstraction"),", is a standard that allows smart contracts to initiate transactions, thus enabling any logic that users want to implement to be encoded into the smart contract wallet itself for execution on Ethereum."),(0,o.kt)("p",null,"Account Abstraction has the potential to be a massive game-changer for onchain user experience and many believe it will play a key role in bringing the next billion users onchain."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"the-problem-account-abstraction-solves"},"The Problem Account Abstraction Solves"),(0,o.kt)("p",null,"Onchain applications are difficult to use for many people, as they require a lengthy onboarding process for the average internet user who already onchain."),(0,o.kt)("p",null,"For example,the preliminary steps a user needs to go through before they can use an onchain app are:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Create a wallet wallet (Coinbase Wallet, Metamask, etc)"),(0,o.kt)("li",{parentName:"ol"},"Store the wallet mnemonic safely, without losing it or compromising it"),(0,o.kt)("li",{parentName:"ol"},"Sign a slightly frightening message to connect to an onchain app"),(0,o.kt)("li",{parentName:"ol"},"Try to do anything with the app and get a popup asking them to approve a transaction"),(0,o.kt)("li",{parentName:"ol"},"Attempt to do so, learn transactions cost gas, and that they don't have any"),(0,o.kt)("li",{parentName:"ol"},"Learn that gas is a fee that users must pay in ETH to use onchain apps"),(0,o.kt)("li",{parentName:"ol"},"Attempt to buy ETH, possibly buying the wrong flavor of ETH in the wrong location"),(0,o.kt)("li",{parentName:"ol"},"Try the transaction again"),(0,o.kt)("li",{parentName:"ol"},"Repeat until they finally find the correct path")),(0,o.kt)("p",null,"For widespread adoption of onchain applications, this confusing and alienating process has to change."),(0,o.kt)("p",null,"That's where Account Abstraction comes in. It allows you to improve the onboarding and usage flow for your users:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"User goes to the onchain app and authenticates (using email, EOA, or social auth)"),(0,o.kt)("li",{parentName:"ol"},"User uses the app"),(0,o.kt)("li",{parentName:"ol"},"Transactions happen under the hood via a smart contract wallet and the app developer sponsors the user's gas fees until after they're onboarded.")),(0,o.kt)("p",null,"To summarize, Account Abstraction enables smart contract accounts to initiate user operations, similar to how an EOA would initiate a transaction. However, unlike EOAs, smart contract accounts are programmable and can enable a number of incredible features, such as:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Sponsored Transactions"),": Allow application owners to cover the users gas fees with a paymaster or allow a user to use something other than ETH (USDC, for example) to cover gas"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Arbitrary Verification Logic"),": Verify transactions with custom logic"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Account Recovery"),": Create account recovery features for when user lose private keys"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Batching Transactions"),": Change the user experience so that multiple transactions can be submitted at once")),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"overview-of-erc-4337---account-abstraction"},"Overview of ERC-4337 - Account Abstraction"),(0,o.kt)("p",null,'"Account Abstraction" comes from ',(0,o.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-4337"},"ERC-4337"),". The proposal itself is a dense read, but one of stated goals of the proposal is to:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"allow users to use smart contract wallets containing arbitrary verification logic instead of EOAs as their primary account. Completely remove any need at all for users to also have EOAs (as status quo SC wallets and EIP-3074 both require)")),(0,o.kt)("p",null,"In other words, the proposal seeks to allow users to use ",(0,o.kt)("em",{parentName:"p"},"smart contract wallets")," ",(0,o.kt)("strong",{parentName:"p"},"instead")," of EOAs to transact onchain."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},'You\'re working with something so new that the vocabulary hasn\'t settled yet. You\'ll often see the terms "smart contract wallet", "smart contract account" or just "smart account" used interchangeably.')),(0,o.kt)("p",null,"At first glance, you may be asking yourself if using smart contract accounts solve our problem. What's the difference between a smart contract account (or contract account) and an ",(0,o.kt)("em",{parentName:"p"},"Externally Owned Account"),"?"),(0,o.kt)("p",null,"According to ",(0,o.kt)("a",{parentName:"p",href:"https://ethereum.org/en/developers/docs/accounts/#key-differences"},"ethereum.org"),", the differences are:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Externally Owned Account")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Creating an account costs nothing"),(0,o.kt)("li",{parentName:"ul"},"Can initiate transactions"),(0,o.kt)("li",{parentName:"ul"},"Transactions between externally-owned accounts can only be ETH/token transfers"),(0,o.kt)("li",{parentName:"ul"},"Made up of a cryptographic pair of keys: public and private keys that control account activities")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Contract Accounts")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Creating a contract has a cost because you're using network storage"),(0,o.kt)("li",{parentName:"ul"},"Can only send transactions in response to receiving a transaction"),(0,o.kt)("li",{parentName:"ul"},"Transactions from an external account to a contract account can trigger code which can execute many different actions, such as transferring tokens or even creating a new contract"),(0,o.kt)("li",{parentName:"ul"},"Contract accounts don't have private keys. Instead, they are controlled by the logic of the smart contract code")),(0,o.kt)("p",null,"Smart contract wallets ",(0,o.kt)("em",{parentName:"p"},"would")," solve our problems, ",(0,o.kt)("strong",{parentName:"p"},"but"),", as stated above, they can't initiate transactions. Since they cannot initiate transactions, users still need EOAs and those EOAs still need to pay for gas with ETH."),(0,o.kt)("p",null,"There were two options to resolve this problem:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Change the protocol - hard fork!")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Change transactions, upstream (ERC-4337)"))),(0,o.kt)("p",null,"In a nutshell, ERC-4337 doesn't change how Ethereum transactions work. Cryptographically signed instructions from accounts still initiate transactions to update the state of the Ethereum network."),(0,o.kt)("p",null,"What ERC-4337 changes is everything ",(0,o.kt)("em",{parentName:"p"},"upstream")," of that signed transaction. It does this by introducing a new ",(0,o.kt)("em",{parentName:"p"},"user intent layer")," that acts as a proxy for an EOA. This layer allows users to initiate transactions, with highly customizable smart contract wallets, but without using an EOA. The Ethereum network still receives what it received before - signed transactions."),(0,o.kt)("p",null,"The result is a better experience for the user without changing the Ethereum protocol."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"how-account-abstraction-works"},"How Account Abstraction Works"),(0,o.kt)("p",null,"With typical Ethereum transactions an EOA initiates and signs a transaction. That transaction is sent to Ethereum's Public Mempool, is validated and added to a block, onchain."),(0,o.kt)("p",null,"Note that the following steps are primarily happening ",(0,o.kt)("strong",{parentName:"p"},"before")," any of that."),(0,o.kt)("h4",{id:"1-smart-contract-wallet-creation"},"1. ",(0,o.kt)("strong",{parentName:"h4"},"Smart Contract Wallet Creation")),(0,o.kt)("p",null,"First, a new smart contract wallet must be created for a user. This wallet is owned by its creator who is designated as the ",(0,o.kt)("em",{parentName:"p"},"signer"),". This signer must validate any of its future operations."),(0,o.kt)("p",null,"This wallet may come with a variety of features, but it must be able to at least validate ",(0,o.kt)("inlineCode",{parentName:"p"},"UserOperations"),"s with a function called, ",(0,o.kt)("inlineCode",{parentName:"p"},"validateUserOp"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"validateUserOp")," will check each ",(0,o.kt)("inlineCode",{parentName:"p"},"UserOperation"),"'s signature, increment the nonce, and handle the operation's fees."),(0,o.kt)("h4",{id:"2-user-operation-creation"},"2. ",(0,o.kt)("strong",{parentName:"h4"},"User Operation Creation")),(0,o.kt)("p",null,"From the smart contract account, ",(0,o.kt)("inlineCode",{parentName:"p"},"UserOperations"),"s are created. These are not yet transactions, but rather represent intents from the user. These intents can represent any onchain user operation."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"UserOperation")," includes the details of the transaction such as sender, nonce, gas limit, max fee per gas, paymaster data (if applicable), and a signature."),(0,o.kt)("h4",{id:"3-signature-generation"},"3. ",(0,o.kt)("strong",{parentName:"h4"},"Signature Generation"),":"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"UserOperation")," is then signed using the private key associated with the initiating account. This signature serves to authenticate the transaction and validate that it was indeed initiated by the owner of the smart contract account."),(0,o.kt)("h4",{id:"4-alt-mempool"},"4. ",(0,o.kt)("strong",{parentName:"h4"},"Alt Mempool"),":"),(0,o.kt)("p",null,"ERC-4337 introduces an ",(0,o.kt)("em",{parentName:"p"},"Alt Mempool")," where operations are stored until they're picked up by a ",(0,o.kt)("em",{parentName:"p"},"Bundler"),". The Alt Mempool is not very different from the transaction pool typically used in Ethereum, but this mempool exists earlier on in the transaction and holds user operations, where Ethereum's mempool holds signed transactions."),(0,o.kt)("h4",{id:"5-bundler-and-operation-submission"},"5. ",(0,o.kt)("strong",{parentName:"h4"},"Bundler and Operation Submission"),":"),(0,o.kt)("p",null,"Nodes on the Ethereum network have the option to serve as a ",(0,o.kt)("em",{parentName:"p"},"Bundler"),", a role that involves collecting multiple signed ",(0,o.kt)("inlineCode",{parentName:"p"},"UserOperation"),"s and consolidating them into a single transaction, called a bundle transaction. These bundle transactions are then directed towards a universal smart contract, called the ",(0,o.kt)("em",{parentName:"p"},"EntryPoint"),"."),(0,o.kt)("p",null,"The submission of the signed ",(0,o.kt)("inlineCode",{parentName:"p"},"UserOperation")," to the EntryPoint contract can be done directly or through a ",(0,o.kt)("em",{parentName:"p"},"paymaster"),", which is a contract that agrees to cover the cost of operations for certain users."),(0,o.kt)("h4",{id:"6-operation-validation"},"6. ",(0,o.kt)("strong",{parentName:"h4"},"Operation Validation"),":"),(0,o.kt)("p",null,"The Bundler triggers a function named ",(0,o.kt)("inlineCode",{parentName:"p"},"handleOps")," on the EntryPoint smart contract, which receives the bundle transaction. The EntryPoint then calls ",(0,o.kt)("inlineCode",{parentName:"p"},"validateUserOp")," for each account within this bundle transaction."),(0,o.kt)("p",null,"Each smart contract wallet is then required to implement an additional function and execute the actual operation sent by the EntryPoint contract."),(0,o.kt)("h4",{id:"7-operation-execution"},"7. ",(0,o.kt)("strong",{parentName:"h4"},"Operation Execution"),":"),(0,o.kt)("p",null,"Once the operation has been validated and the fees have been handled, the operation is executed on the Ethereum network."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"intro-to-privy-1"},"Intro to Privy"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://www.privy.dev/"},"Privy")," makes authentication and user-management in onchain apps easier by bridging onchain and offchain user data. In preparation to dive into our Base Paymaster example app, this lesson will cover the basics of Privy."),(0,o.kt)("p",null,"In this tutorial, you'll quick start and review a sample application where users can authenticate with ",(0,o.kt)("a",{parentName:"p",href:"https://www.privy.dev/"},"Privy"),"."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"overview-of-privy"},"Overview of Privy"),(0,o.kt)("p",null,"Privy self-describes as \"a simple toolkit for progressive authentication in web3\". In this app, you'll primarily use Privy for its authentication and user-handling capabilities, but some of Privy's most popular features include:"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Authentication Options"),": Privy allows developers to configure how users authenticate. This can be with a crypto wallet, an email address, phone number or social profiles. Conveniently, Privy handles sessions and provides all necessary authentication methods."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Progressive Onboarding"),": Privy creates a ",(0,o.kt)("inlineCode",{parentName:"p"},"user")," object for each session. Before authentication, this ",(0,o.kt)("inlineCode",{parentName:"p"},"user")," object is ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),", but as the user interacts with your application it will progressively associate more user information with this object. For example, users can start by authenticating with their email address and later add their wallet address or any other user information as the application requires."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Embedded Wallets"),": Embedded wallets are \"self-custodial Ethereum wallets that are embedded into your app. This allows your users to take wallet-based actions without ever leaving your site. Embedded wallets are the easiest way to unlock your full product experience for users who don't have, or don't want to connect, their own wallet.\" Developers can simply configure Privy to automatically created an Embedded Wallet on ",(0,o.kt)("inlineCode",{parentName:"p"},"login")," or they can be pregenerated on the backend."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("em",{parentName:"p"},"Embedded wallets")," are still EOAs and should not be confused with ",(0,o.kt)("em",{parentName:"p"},"smart contract wallets"),". A user may have both. During development, this division can lead to confusing situations where ",(0,o.kt)("inlineCode",{parentName:"p"},"msg.sender")," is ",(0,o.kt)("strong",{parentName:"p"},"not")," the address you were expecting.")),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"privy-quick-start"},"Privy Quick Start"),(0,o.kt)("p",null,"As with most onchain frontend connector libraries, you can use ",(0,o.kt)("a",{parentName:"p",href:"https://docs.privy.io/guide/quickstart"},"Privy's Quick Start")," to jump start your development with their platform. In this example, you'll use the NextJS starter."),(0,o.kt)("h4",{id:"setup"},"Setup"),(0,o.kt)("p",null,"First, navigate to the repository: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/privy-io/create-next-app"},"https://github.com/privy-io/create-next-app")," and clone the repo."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/privy-io/create-next-app\n")),(0,o.kt)("p",null,"Next, ",(0,o.kt)("inlineCode",{parentName:"p"},"cd create-next-app")," and install dependencies with ",(0,o.kt)("inlineCode",{parentName:"p"},"yarn"),"."),(0,o.kt)("h4",{id:"setting-your-app-id"},"Setting Your App Id"),(0,o.kt)("p",null,"To use Privy, you'll need your own environment variables. In your terminal, run:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"cp .env.example .env.local\n")),(0,o.kt)("p",null,"This will create a ",(0,o.kt)("inlineCode",{parentName:"p"},".env.local")," file in your project's root. This is where you'll add your Privy App ID:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"NEXT_PUBLIC_PRIVY_APP_ID=<your-privy-app-id>\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Note - to get an App ID, you'll need to request one and access it at ","[https://console.privy.io/]",". This process can take a while, but for the Base community, Privy will expedite this process! Developers can send an email to ",(0,o.kt)("inlineCode",{parentName:"p"},"base@privy.io")," with:"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"Your app name"),(0,o.kt)("li",{parentName:"ul"},"The email address you want as admin"),(0,o.kt)("li",{parentName:"ul"},"A one liner on what you're building"))),(0,o.kt)("h4",{id:"starting-the-app"},"Starting the App"),(0,o.kt)("p",null,"Finally, run ",(0,o.kt)("inlineCode",{parentName:"p"},"yarn dev")," and navigate to ","[http://localhost:3000]"," to see the starter application."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"privy-login-walkthrough"},"Privy Login Walkthrough"),(0,o.kt)("p",null,"Before exploring the code, test the app. First, you should see this login page:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Privy Login Page",src:a(2726).Z,width:"871",height:"942"})),(0,o.kt)("p",null,'After clicking "Log in" you\'ll see the following modal:'),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Privy Login Modal",src:a(94481).Z,width:"683",height:"931"})),(0,o.kt)("p",null,"By default, you can login with a wallet, or email."),(0,o.kt)("p",null,"After logging in, you'll be redirected to the ",(0,o.kt)("inlineCode",{parentName:"p"},"/dashboard")," page, where the demo app will allow you to connect a number of other accounts to your ",(0,o.kt)("inlineCode",{parentName:"p"},"user")," object:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Privy Dashboard Page",src:a(46462).Z,width:"933",height:"656"})),(0,o.kt)("p",null,"If you navigate to ",(0,o.kt)("a",{parentName:"p",href:"https://console.privy.io/"},"console.privy.io"),", you'll see that Privy stores all your users and their data here."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Privy Console",src:a(20303).Z,width:"1402",height:"768"})),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"privyprovider"},"PrivyProvider"),(0,o.kt)("p",null,"Diving into the code, first look at the ",(0,o.kt)("inlineCode",{parentName:"p"},"PrivyProvider")," inside of ",(0,o.kt)("inlineCode",{parentName:"p"},"_app.jsx"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<PrivyProvider\n  appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ''}\n  onSuccess={() => router.push('/dashboard')}\n>\n  <Component {...pageProps} />\n</PrivyProvider>\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"PrivyProvider")," uses React Context and wraps any components that will use the ",(0,o.kt)("inlineCode",{parentName:"p"},"usePrivy")," hook."),(0,o.kt)("p",null,"Additionally, it's here that you can pass an optional ",(0,o.kt)("inlineCode",{parentName:"p"},"config")," property to enable more authentication methods."),(0,o.kt)("p",null,"Add a ",(0,o.kt)("inlineCode",{parentName:"p"},"config")," property to the ",(0,o.kt)("inlineCode",{parentName:"p"},"<PrivyProvider />")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"_app.jsx")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"'github'")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"'sms'")," as the login options:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<PrivyProvider\n  appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ''}\n  onSuccess={() => router.push('/dashboard')}\n  config={{\n    loginMethods: ['github', 'sms'],\n  }}\n>\n  <Component {...pageProps} />\n</PrivyProvider>\n")),(0,o.kt)("p",null,"Refresh to see that authentication is only possible now through Github or SMS:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Privy Login Methods",src:a(98434).Z,width:"458",height:"476"})),(0,o.kt)("p",null,"You can find a full list of ",(0,o.kt)("inlineCode",{parentName:"p"},"loginMethods")," in the docs for ",(0,o.kt)("a",{parentName:"p",href:"https://docs.privy.io/reference/react-auth/modules#privyclientconfig"},(0,o.kt)("inlineCode",{parentName:"a"},"PrivyClientConfig")),"."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"the-useprivy-hook"},"The ",(0,o.kt)("inlineCode",{parentName:"h3"},"usePrivy")," Hook"),(0,o.kt)("p",null,"The primary method you'll use to utilize Privy's authentication features is ",(0,o.kt)("inlineCode",{parentName:"p"},"usePrivy"),". Open ",(0,o.kt)("inlineCode",{parentName:"p"},"pages/dashboard.tsx")," to see the methods decomposed from ",(0,o.kt)("inlineCode",{parentName:"p"},"usePrivy")," in the starter, and how they are used."),(0,o.kt)("p",null,"A full list of the fields and methods returned from ",(0,o.kt)("inlineCode",{parentName:"p"},"usePrivy")," are ",(0,o.kt)("a",{parentName:"p",href:"https://docs.privy.io/reference/react-auth/interfaces/PrivyInterface"},"documented here"),"."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"the-usewallets-hook"},"The ",(0,o.kt)("inlineCode",{parentName:"h3"},"useWallets")," Hook"),(0,o.kt)("p",null,"To access wallet data for currently authenticated user, use the ",(0,o.kt)("inlineCode",{parentName:"p"},"useWallets")," hook:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'import { ConnectedWallet, useWallets } from \'@privy-io/react-auth\';\n\nconst { wallets } = useWallets();\n\n// wallets = [\n//   {\n//     "address": "0x<address>",\n//     "type": "wallet",\n//     "verifiedAt": "2023-11-28T19:01:41.000Z",\n//     "chainType": "ethereum",\n//     "chainId": "eip155:84531",\n//     "walletClient": "unknown",\n//     "walletClientType": "coinbase_wallet",\n//     "connectorType": "coinbase_wallet"\n//   },\n//   {\n//     "address": "0x<address>",\n//     "type": "wallet",\n//     "verifiedAt": "2023-11-28T20:09:23.000Z",\n//     "chainType": "ethereum",\n//     "chainId": "eip155:1",\n//     "walletClient": "unknown",\n//     "walletClientType": "metamask",\n//     "connectorType": "injected"\n//   },\n// ],\n')),(0,o.kt)("p",null,"As you can see, a user may connect multiple wallets to Privy, including Embedded Wallets."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"embedded-wallets"},"Embedded Wallets"),(0,o.kt)("p",null,"Lastly, configure your starter app to create an Embedded Wallet for your users on login."),(0,o.kt)("p",null,"As stated in the Privy docs,"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Embedded wallets are self-custodial Ethereum wallets that are embedded into your app. This allows your users to take wallet-based actions without ever leaving your site. Embedded wallets are the easiest way to unlock your full product experience for users who don't have, or don't want to connect, their own wallet.")),(0,o.kt)("p",null,"When configuring your app to create embedded wallets on login, you have 2 options:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"users-without-wallets"),": This will create embedded wallets for all use who did not login with an external wallet"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"all-users"),": This will create an additional embedded wallet for all users, regardless if they have linked an external wallet")),(0,o.kt)("p",null,"Inside of ",(0,o.kt)("inlineCode",{parentName:"p"},"_app.tsx"),", update your ",(0,o.kt)("inlineCode",{parentName:"p"},"PrivyProvider"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<PrivyProvider\n  appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ''}\n  onSuccess={() => router.push('/dashboard')}\n  config={{\n    embeddedWallets: {\n      createOnLogin: 'all-users'\n    }\n  }}\n>\n")),(0,o.kt)("p",null,"Log out of your application, then log in again and see that your user has an additional ",(0,o.kt)("inlineCode",{parentName:"p"},"linkedAccount")," which is the Privy Embedded Wallet:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'{\n  "address": "0xD5063967BA703D485e3Ca40Ecd61882dfa5F49b2",\n  "type": "wallet",\n  "verifiedAt": "2023-11-28T20:52:22.000Z",\n  "chainType": "ethereum",\n  "chainId": "eip155:1",\n  "walletClient": "privy",\n  "walletClientType": "privy",\n  "connectorType": "embedded",\n  "recoveryMethod": "privy"\n},\n')),(0,o.kt)("p",null,"More information on Privy's Embedded Wallets, including information about the addresses, signing transactions, funding the wallet and more, can be found here: ",(0,o.kt)("a",{parentName:"p",href:"https://docs.privy.io/guide/frontend/embedded/overview"},"https://docs.privy.io/guide/frontend/embedded/overview")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"implementing-the-paymaster-1"},"Implementing the Paymaster"),(0,o.kt)("p",null,"A ",(0,o.kt)("em",{parentName:"p"},"paymaster")," is a type of smart contract account, introduced in ",(0,o.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-4337"},"ERC-4337"),", that is able to pay for gas on behalf of another account. In this step-by-step, you'll modify an example created by ",(0,o.kt)("a",{parentName:"p",href:"https://www.privy.dev/"},"Privy"),", move it to another onchain app, and use it to call a smart contract function. Along the way, you'll encounter and resolve some of the confusing pitfalls associated with working with smart contract accounts."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"The tutorial below does not account for recent changes to the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/base-org/paymaster"},"Base Paymaster"),". Please reference the linked repo and adjust. We'll update the tutorial soon!")),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"reviewing-the-example"},"Reviewing the Example"),(0,o.kt)("p",null,"Start by reviewing the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/privy-io/base-paymaster-example/blob/main/README.md"},"paymaster example"),". The address in the ",(0,o.kt)("inlineCode",{parentName:"p"},"about")," section of the Github page links to a deployed version of the app. It's the same app you get from ",(0,o.kt)("a",{parentName:"p",href:"https://docs.privy.io/guide/quickstart"},"Privy's Quick Start"),", with the addition of a mint button (the versions may be a little older)."),(0,o.kt)("p",null,"The app is limited to social auth, so log in with either your Google account or email. You'll see the dashboard, with the addition of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Mint NFT")," button at the top."),(0,o.kt)("p",null,"Click the button and you'll see a toast notification informing you of updates to the transaction status. Note that this happens ",(0,o.kt)("strong",{parentName:"p"},"without")," you needing to approve a transaction or fund a wallet!"),(0,o.kt)("p",null,"Click to see the transaction when it's done to open BaseScan. If you missed it, mint another NFT, it's not like you're paying gas!"),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"reviewing-the-transaction-and-contract"},"Reviewing the Transaction and Contract"),(0,o.kt)("p",null,"The transaction page should appear fairly standard. You can see from it that an NFT was minted by the ",(0,o.kt)("a",{parentName:"p",href:"https://goerli.basescan.org/address/0x6527e5052de5521fe370ae5ec0afcc6cd5a221de"},"NFT Contract")," and transferred to the smart wallet address listed on the dashboard. Digging in a little more, you'll see some things that might be different than what you'd expect."),(0,o.kt)("h4",{id:"tokens-transferred-and-the-nft-contract"},"Tokens Transferred and the NFT Contract"),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"ERC-721 Tokens Transferred")," section, click the link to ",(0,o.kt)("inlineCode",{parentName:"p"},"NFT Name (NFT)")," to open up the overview page for the token. You'll see a list of transfers, with yours likely on the top. Click the address for the contract to open up the ",(0,o.kt)("a",{parentName:"p",href:"https://goerli.basescan.org/address/0x6527e5052de5521fe370ae5ec0afcc6cd5a221de"},"view for the contract itself"),"."),(0,o.kt)("p",null,"You may be surprised to see that there are very few transactions listed for this contract, despite the list of transfers you can see on the token page, or the ",(0,o.kt)("inlineCode",{parentName:"p"},"Events")," tab. Currently, Etherscan and BaseScan won't display transactions done via the paymaster."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Blockchain explorers are service providers that provide information about the state of various blockchains. They are ",(0,o.kt)("strong",{parentName:"p"},"not")," a source of truth."),(0,o.kt)("p",{parentName:"admonition"},"It is possible for onchain activity to be missing from these services.")),(0,o.kt)("h4",{id:"the-bundler-transaction-sender"},"The Bundler (Transaction Sender)"),(0,o.kt)("p",null,"Return to the transactions summary and look at the ",(0,o.kt)("inlineCode",{parentName:"p"},"From:")," field. It will contain ",(0,o.kt)("inlineCode",{parentName:"p"},"0x1e6754b227c6ae4b0ca61d82f79d60660737554a"),". What is this address? It's not your smart wallet address or signer address. If you mint another NFT from a different login, you'll get the same sender."),(0,o.kt)("p",null,"This address is the ",(0,o.kt)("a",{parentName:"p",href:"https://www.alchemy.com/overviews/what-is-a-bundler"},"bundler"),", which is a special node that bundles user operations from the alt mempool into a single transaction and sends them to the single ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/eth-infinitism/account-abstraction/releases"},"EntryPoint")," contract."),(0,o.kt)("h4",{id:"entrypoint"},"EntryPoint"),(0,o.kt)("p",null,"The EntryPoint contract for Base Goerli is located at ",(0,o.kt)("inlineCode",{parentName:"p"},"0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789"),". Strangely, in your transaction receipt you'll see that the transaction includes a transfer of ETH ",(0,o.kt)("strong",{parentName:"p"},"from")," the EntryPoint ",(0,o.kt)("strong",{parentName:"p"},"to")," the bundler. This transaction is how the bundler gets compensated for performing the service of bundling user ops and turning them into transactions -- the EntryPoint calculates the gas used by user ops and multiplies that by the fee percentage and send it to the bundler."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"review-the-example-code"},"Review the Example Code"),(0,o.kt)("p",null,"Return to the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/privy-io/base-paymaster-example/blob/main/README.md"},"paymaster example")," and review the readme. The section on ",(0,o.kt)("em",{parentName:"p"},"Copying into your code")," lists the three files you'll need to copy over to implement the paymaster in your own app. All three are extensively documented via comments. You'll also want to review how the demo app uses these to call a function."),(0,o.kt)("h4",{id:"smartaccountcontexttsx"},(0,o.kt)("inlineCode",{parentName:"h4"},"SmartAccountContext.tsx")),(0,o.kt)("p",null,"The first file, ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/privy-io/base-paymaster-example/blob/main/hooks/SmartAccountContext.tsx"},(0,o.kt)("inlineCode",{parentName:"a"},"hooks/SmartAccountContext.tsx"))," uses a React Context provider to create a ",(0,o.kt)("inlineCode",{parentName:"p"},"SmartAccountProvider`` and pass it into your app. You can see it in use in "),"_","app.tsx",(0,o.kt)("inlineCode",{parentName:"p"},", with the regular "),"PrivyProvider` around it. Review the file in detail."),(0,o.kt)("p",null,"Starting on line 63, the exported ",(0,o.kt)("inlineCode",{parentName:"p"},"SmartAccountProvider")," does the following:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Fetch the user's wallets and find their Privy wallet. This wallet is provided, and if need be created, by the ",(0,o.kt)("inlineCode",{parentName:"li"},"PrivyProvider")),(0,o.kt)("li",{parentName:"ol"},"Set up state variables to manage and share connection status and the smart account itself"),(0,o.kt)("li",{parentName:"ol"},"Initialize an RPC client for the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/base-org/paymaster"},"Base Paymaster")," (on Goerli). The URL is hardcoded in ",(0,o.kt)("inlineCode",{parentName:"li"},"lib/constants.ts")),(0,o.kt)("li",{parentName:"ol"},"Initialize an ERC-4337 RPC client for Alchemy's network. This network is where the bundler address comes from"),(0,o.kt)("li",{parentName:"ol"},"Create a smart wallet. In this case, the ",(0,o.kt)("inlineCode",{parentName:"li"},"signer")," is your EOA embedded wallet created by Privy and fetched in the first step"),(0,o.kt)("li",{parentName:"ol"},"The EOA address is displayed in the example app as ",(0,o.kt)("inlineCode",{parentName:"li"},"YOUR SIGNER ADDRESS")),(0,o.kt)("li",{parentName:"ol"},"Initialize an Alchemy provider for the smart account signer, using Alchemy's ",(0,o.kt)("a",{parentName:"li",href:"https://www.alchemy.com/blog/introducing-account-kit"},"Account Kit"),"."),(0,o.kt)("li",{parentName:"ol"},"This creates the smart account and its address, which is displayed in the example app as ",(0,o.kt)("inlineCode",{parentName:"li"},"YOUR SMART WALLET ADDRESS"))),(0,o.kt)("p",null,"Finally, the ",(0,o.kt)("inlineCode",{parentName:"p"},"sendSponsoredUserOperation")," function takes a traditional transaction, turns it into a user operation, adds the data for the paymaster to pay the gas, signs it, and sends it. Whew!"),(0,o.kt)("p",null,"If you want a deeper dive into the inner workings of this process, review the helper functions in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/privy-io/base-paymaster-example/blob/main/lib/user-operations.ts"},(0,o.kt)("inlineCode",{parentName:"a"},"user-operations.ts")),"."),(0,o.kt)("h4",{id:"how-to-call-a-smart-contract-function-with-the-paymaster"},"How to Call a Smart Contract Function with the Paymaster"),(0,o.kt)("p",null,"Open ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/privy-io/base-paymaster-example/blob/main/pages/dashboard.tsx"},(0,o.kt)("inlineCode",{parentName:"a"},"pages/dashboard.tsx"))," and take a look at the ",(0,o.kt)("inlineCode",{parentName:"p"},"onMint")," function on line 32. This function is used as the ",(0,o.kt)("inlineCode",{parentName:"p"},"oncClick")," handler for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Mint")," button at the top of the dashboard."),(0,o.kt)("p",null,"If you're used to working with wagmi, you'll find the process of sending and awaiting for confirmation of a transaction a little on the manual side. Most of this will be familiar if you've used viem directly, or have worked with ",(0,o.kt)("em",{parentName:"p"},"Ethers"),"."),(0,o.kt)("p",null,"When a user clicks, the app first creates a viem ",(0,o.kt)("inlineCode",{parentName:"p"},"RpcTransactionRequest")," for the ",(0,o.kt)("inlineCode",{parentName:"p"},"mint")," function on the smart contract. The ",(0,o.kt)("inlineCode",{parentName:"p"},"smartContractAddress")," is supplied by the ",(0,o.kt)("inlineCode",{parentName:"p"},"SmartAccountProvider"),", and the ",(0,o.kt)("inlineCode",{parentName:"p"},"ABI")," and contract ",(0,o.kt)("inlineCode",{parentName:"p"},"NFT_ADDRESS")," are loaded from ",(0,o.kt)("inlineCode",{parentName:"p"},"lib/constants.ts"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'{\n  from: smartAccountAddress,\n  to: NFT_ADDRESS,\n  data: encodeFunctionData({\n    abi: ABI,\n    functionName: "mint",\n    args: [smartAccountAddress],\n  }),\n}\n')),(0,o.kt)("p",null,"The app then updates the toast component to update the users while it ",(0,o.kt)("inlineCode",{parentName:"p"},"await"),"s first the ",(0,o.kt)("inlineCode",{parentName:"p"},"userOpHash"),", then the ",(0,o.kt)("inlineCode",{parentName:"p"},"transactionHash"),", indicating that transaction has completed successfully. It then updates the link in the toast to send the user to that transaction on Goerli BaseScan."),(0,o.kt)("hr",null),(0,o.kt)("h3",{id:"implementing-the-paymaster-in-your-own-app"},"Implementing the Paymaster in your own App"),(0,o.kt)("p",null,"Create a new project using Privy's ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/privy-io/create-next-app"},(0,o.kt)("inlineCode",{parentName:"a"},"create-next-app"))," template, and complete the setup instructions in the readme."),(0,o.kt)("p",null,"Add an environment variable for ",(0,o.kt)("inlineCode",{parentName:"p"},"NEXT_PUBLIC_ALCHEMY_API_KEY")," and paste in the an API key for a Base Goerli app. If you need a key, go to ",(0,o.kt)("a",{parentName:"p",href:"https://dashboard.alchemy.com/apps"},"add an app")," and create a new one."),(0,o.kt)("h4",{id:"copying-and-updating-the-source-files"},"Copying and Updating the Source Files"),(0,o.kt)("p",null,"Copy the ",(0,o.kt)("inlineCode",{parentName:"p"},"hooks")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"lib")," folders into your ",(0,o.kt)("em",{parentName:"p"},"new")," project. You'll need to install some more dependencies. Use ",(0,o.kt)("inlineCode",{parentName:"p"},"npm")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"yarn")," to add:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"viem"),(0,o.kt)("li",{parentName:"ul"},"react-dom"),(0,o.kt)("li",{parentName:"ul"},"@alchemy/aa-accounts"),(0,o.kt)("li",{parentName:"ul"},"@alchemy/aa-alchemy"),(0,o.kt)("li",{parentName:"ul"},"@alchemy/aa-core")),(0,o.kt)("p",null,"Open ",(0,o.kt)("inlineCode",{parentName:"p"},"SmartAccountContext.tsx")," in your project. You'll see an error for ",(0,o.kt)("inlineCode",{parentName:"p"},"getDefaultLightAccountFactory"),". The name of this function has been updated to ",(0,o.kt)("inlineCode",{parentName:"p"},"getDefaultLightAccountFactoryAddress"),". Change it in the import, and where it is used in the file in the call to ",(0,o.kt)("inlineCode",{parentName:"p"},"LightSmartContractAccount"),"."),(0,o.kt)("h4",{id:"updating-to-use-the-users-wallet"},"Updating to Use the User's Wallet"),(0,o.kt)("p",null,"The app is currently configured to find and use the user's embedded Privy wallet as the signer. To change this, modify the instantiation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"SmartAccountProvider"),". Instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"find"),"ing the user's Privy wallet:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// Old code to change\n\n// Get a list of all of the wallets (EOAs) the user has connected to your site\nconst { wallets } = useWallets();\n// Find the embedded wallet by finding the entry in the list with a `walletClientType` of 'privy'\nconst embeddedWallet = wallets.find((wallet) => wallet.walletClientType === 'privy');\n")),(0,o.kt)("p",null,"Simply grab the first wallet in the list (you'll want to do something more elegant for a production app):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// Updated Code\n\n// Get a list of all of the wallets (EOAs) the user has connected to your site\nconst { wallets } = useWallets();\n\n// Grab the first wallet on the list\n// TODO: Implement the option to allow the user to choose another wallet\nconst wallet = wallets[0];\n")),(0,o.kt)("p",null,"Then, update the call at the bottom of ",(0,o.kt)("inlineCode",{parentName:"p"},"useEffect")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"createSmartWallet")," if there is an ",(0,o.kt)("inlineCode",{parentName:"p"},"embeddedWallet")," to instead create it if there is a ",(0,o.kt)("inlineCode",{parentName:"p"},"wallet"),", using that ",(0,o.kt)("inlineCode",{parentName:"p"},"wallet"),". You'll also need to update the dependency in the dependency array."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"useEffect(() => {\n  // Other code\n\n  if (wallet) createSmartWallet(wallet);\n}, [wallet?.address]);\n")),(0,o.kt)("h4",{id:"configuring-the-privyprovider-and-adding-smartaccountprovider"},"Configuring the PrivyProvider and Adding SmartAccountProvider"),(0,o.kt)("p",null,"By default, the ",(0,o.kt)("inlineCode",{parentName:"p"},"PrivyProvider")," allows logging in with a wallet or email address. To limit it to only the wallet, update the config. You can also set the default chain here. You'll need to import ",(0,o.kt)("inlineCode",{parentName:"p"},"baseGoerli")," to do so."),(0,o.kt)("p",null,"You also need to import and wrap the app with ",(0,o.kt)("inlineCode",{parentName:"p"},"SmartAccountProvider"),", imported from ",(0,o.kt)("inlineCode",{parentName:"p"},"hooks/SmartAccountContext.tsx"),"."),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"@alchemy/aa-core")," package also exports ",(0,o.kt)("inlineCode",{parentName:"p"},"SmartAccountProvider")," and this export takes precedence when VSCode attempts to help you by automatically adding the import. You'll know you've got the wrong one if ",(0,o.kt)("inlineCode",{parentName:"p"},"SmartAccountProvider")," generates an error that:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-text"},"'SmartAccountProvider' cannot be used as a JSX component.\nIts instance type 'SmartAccountProvider<Transport>' is not a valid JSX element.\n"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<PrivyProvider\n  appId={process.env.NEXT_PUBLIC_PRIVY_APP_ID || ''}\n  onSuccess={() => router.push('/dashboard')}\n  config={{\n    loginMethods: ['wallet'],\n    defaultChain: baseGoerli,\n  }}\n>\n  <SmartAccountProvider>\n    <Component {...pageProps} />\n  </SmartAccountProvider>\n</PrivyProvider>\n")),(0,o.kt)("h4",{id:"checking-progress"},"Checking Progress"),(0,o.kt)("p",null,"Grab the snippet from the original demo that displays the user's addresses, and add it to ",(0,o.kt)("inlineCode",{parentName:"p"},"dashboard.tsx")," in the new project:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'<p className="mt-6 font-bold uppercase text-sm text-gray-600">\n  Your Smart Wallet Address\n</p>\n<a\n  className="mt-2 text-sm text-gray-500 hover:text-violet-600"\n  href={`${BASE_GOERLI_SCAN_URL}/address/${smartAccountAddress}#tokentxnsErc721`}\n>\n  {smartAccountAddress}\n</a>\n<p className="mt-6 font-bold uppercase text-sm text-gray-600">\n  Your Signer Address\n</p>\n<a\n  className="mt-2 text-sm text-gray-500 hover:text-violet-600"\n  href={`${BASE_GOERLI_SCAN_URL}/address/${eoa?.address}`}\n>\n  {eoa?.address}\n</a>\n')),(0,o.kt)("p",null,"Paste it above the ",(0,o.kt)("inlineCode",{parentName:"p"},"<p>")," for the ",(0,o.kt)("inlineCode",{parentName:"p"},"User Object")," window."),(0,o.kt)("p",null,"You'll need to import ",(0,o.kt)("inlineCode",{parentName:"p"},"BASE_GOERLI_SCAN_URL")," from ",(0,o.kt)("inlineCode",{parentName:"p"},"constants.ts"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"useSmartAccount")," hook returns ",(0,o.kt)("inlineCode",{parentName:"p"},"smartAccountProvider")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"eoa"),". Import it and add it under the ",(0,o.kt)("inlineCode",{parentName:"p"},"usePrivy")," hook. You don't need them just yet, but go ahead and decompose ",(0,o.kt)("inlineCode",{parentName:"p"},"smartAccountProvider")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"sendSponsoredUserOperation")," as well:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const router = useRouter();\nconst {\n  ready,\n  authenticated,\n  user,\n  logout,\n  linkEmail,\n  linkWallet,\n  unlinkEmail,\n  linkPhone,\n  unlinkPhone,\n  unlinkWallet,\n  linkGoogle,\n  unlinkGoogle,\n  linkTwitter,\n  unlinkTwitter,\n  linkDiscord,\n  unlinkDiscord,\n} = usePrivy();\nconst { smartAccountAddress, smartAccountProvider, sendSponsoredUserOperation, eoa } =\n  useSmartAccount();\n")),(0,o.kt)("p",null,"Run the app. You'll now see your familiar wallet address as ",(0,o.kt)("inlineCode",{parentName:"p"},"YOUR SIGNER ADDRESS"),"!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-caution"},"\nThe app sometimes gets confused with login state after you've made changes to `config`.  If you see the `Log In` button but clicking it does nothing, try manually navigating to `localhost:3000/dashboard` or clearing the cache.\n\n")),(0,o.kt)("h4",{id:"calling-a-smart-contract-function"},"Calling a Smart Contract Function"),(0,o.kt)("p",null,"You've adjusted the foundation of the app to allow you to use the Base Goerli Paymaster with your normal wallet as the signer. Now, it's time to call a smart contract function."),(0,o.kt)("p",null,"Start by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"mint")," function in the original example. In the ",(0,o.kt)("inlineCode",{parentName:"p"},"DashboardPage")," component, add a state variable holding an empty element:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const [transactionLink, setTransactionLink] = useState(<></>);\n")),(0,o.kt)("p",null,"Then, add a variant of the original ",(0,o.kt)("inlineCode",{parentName:"p"},"onMint")," function that sets this variable and has the code related to the toast removed."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," make sure you change your wallet address in ",(0,o.kt)("inlineCode",{parentName:"p"},"args")," to make sure the NFT is sent to your EOA wallet address!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const onMint = async () => {\n  // The mint button is disabled if either of these are undefined\n  if (!smartAccountProvider || !smartAccountAddress) return;\n\n  try {\n    // From a viem `RpcTransactionRequest` (e.g. calling an ERC-721's `mint` method),\n    // build and send a user operation. Gas fees will be sponsored by the Base Paymaster.\n    const userOpHash = await sendSponsoredUserOperation({\n      from: smartAccountAddress,\n      to: NFT_ADDRESS,\n      data: encodeFunctionData({\n        abi: ABI,\n        functionName: 'mint',\n        args: [eoa?.address],\n      }),\n    });\n\n    // Once we have a hash for the user operation, watch it until the transaction has\n    // been confirmed.\n    const transactionHash = await smartAccountProvider.waitForUserOperationTransaction(userOpHash);\n\n    setTransactionLink(\n      <a href={`${BASE_GOERLI_SCAN_URL}/tx/${transactionHash}`}>\n        Successfully minted! Click here to see your transaction.\n      </a>,\n    );\n  } catch (error) {\n    setTransactionLink(<p>{'Mint failed with error: ' + error}</p>);\n  }\n};\n")),(0,o.kt)("p",null,"Finally, above where you added the addresses, add a button to call the function, and display the link to the transaction:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'<button\n  onClick={onMint}\n  className="rounded-md bg-violet-600 px-4 py-2 text-sm text-white hover:bg-violet-700 disabled:bg-violet-400"\n  disabled={!smartAccountProvider || !smartAccountAddress}\n>\n  Mint NFT\n</button>;\n{\n  transactionLink;\n}\n')),(0,o.kt)("p",null,"Run it and confirm it works. You need the full transaction receipt for the process to finish, so expect to wait as long as 10 or 15 seconds."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"For simplicity, we've stripped out the code to disable the button while it is minting. You'll want to implement your own solution to avoid confusing your users!")),(0,o.kt)("h4",{id:"calling-another-function"},"Calling Another Function"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/base-org/paymaster"},"Base Paymaster")," on Goerli is very permissive. To call another function, all you need to do is to change the ",(0,o.kt)("inlineCode",{parentName:"p"},"RpcTransactionRequest")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"sendSponsoredUserOperation")," to match the address, abi, function name, and arguments of your function on your smart contract."),(0,o.kt)("p",null,"For example, to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"claim")," function in the Weighted Voting contract we've used in other tutorials, you'd simply need to import the Hardhat-style ",(0,o.kt)("a",{parentName:"p",href:"https://gist.github.com/briandoyle81CB/2c2849b5723058792bece666f0a318cb"},"artifact")," for the contract and use it to call the function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const userOpHash = await sendSponsoredUserOperation({\n  from: smartAccountAddress,\n  to: weightedVoting.address as `0x${string}`,\n  data: encodeFunctionData({\n    abi: weightedVoting.abi,\n    functionName: 'claim',\n  }),\n});\n")),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"The function in this example can only be called once per address. It will then fail, because one wallet cannot claim more than one batch of tokens.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"In this article, we've explored the transformative potential of Account Abstraction for the Ethereum ecosystem, highlighting how it enables smart contract accounts to initiate transactions without altering the core protocol. This innovation, coupled with the utilization of Privy for streamlined user onboarding and secure data management, marks a significant advancement towards reducing onboarding friction for onchain applications. Through a practical implementation involving Privy and the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/base-org/paymaster"},"Base Paymaster"),", we demonstrated how users can perform onchain actions without incurring gas fees, showcasing the adaptability and user-centric benefits of these technologies. This tutorial not only sheds light on the technical workings of Account Abstraction but also illustrates its practical application in enhancing the blockchain user experience."),(0,o.kt)("hr",null))}u.isMDXComponent=!0},20303:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/privy-console-1bce635ff19f7ebbc37269dcc349ce34.png"},46462:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/privy-dashboard-page-35ac8d6bb52a300ce94e6a9cdb9b97ba.png"},98434:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/privy-login-methods-1a592de2b1d3bfaad3989bb0206d6dcb.png"},94481:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/privy-login-modal-40f18db3d2278233f234c92d02a55e3b.png"},2726:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/privy-login-page-8e388d1b1230e3ff1c71705c0d3b3c8b.png"}}]);