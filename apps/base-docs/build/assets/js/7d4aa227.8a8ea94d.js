"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[6394],{30876:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=r,u=p["".concat(l,".").concat(m)]||p[m]||h[m]||i;return n?a.createElement(u,o(o({ref:t},d),{},{components:n})):a.createElement(u,o({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},78754:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7896),r=(n(2784),n(30876));const i={title:"Sending messages and tokens from Base to other chains using Chainlink CCIP",slug:"/cross-chain-with-ccip",description:"A tutorial that teaches how to use Chainlink CCIP to perform cross-chain messaging and token transfers from Base Goerli testnet to Optimism Goerli testnet.",author:"taycaldwell",keywords:["Cross-chain","Omni-chain","Crosschain","OmniChain","Chainlink","Chainlink CCIP","CCIP","cross-chain messaging","transfer tokens across chains"],tags:["cross-chain"],difficulty:"intermediate",displayed_sidebar:null},o=void 0,s={unversionedId:"docs/cross-chain-with-ccip",id:"docs/cross-chain-with-ccip",title:"Sending messages and tokens from Base to other chains using Chainlink CCIP",description:"A tutorial that teaches how to use Chainlink CCIP to perform cross-chain messaging and token transfers from Base Goerli testnet to Optimism Goerli testnet.",source:"@site/tutorials/docs/2_cross-chain-with-ccip.md",sourceDirName:"docs",slug:"/cross-chain-with-ccip",permalink:"/tutorials/cross-chain-with-ccip",draft:!1,tags:[{label:"cross-chain",permalink:"/tutorials/tags/cross-chain"}],version:"current",sidebarPosition:2,frontMatter:{title:"Sending messages and tokens from Base to other chains using Chainlink CCIP",slug:"/cross-chain-with-ccip",description:"A tutorial that teaches how to use Chainlink CCIP to perform cross-chain messaging and token transfers from Base Goerli testnet to Optimism Goerli testnet.",author:"taycaldwell",keywords:["Cross-chain","Omni-chain","Crosschain","OmniChain","Chainlink","Chainlink CCIP","CCIP","cross-chain messaging","transfer tokens across chains"],tags:["cross-chain"],difficulty:"intermediate",displayed_sidebar:null}},l={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Foundry",id:"foundry",level:3},{value:"Coinbase Wallet",id:"coinbase-wallet",level:3},{value:"Wallet funds",id:"wallet-funds",level:3},{value:"What is Chainlink CCIP?",id:"what-is-chainlink-ccip",level:2},{value:"High-level concepts",id:"high-level-concepts",level:3},{value:"OnRamps",id:"onramps",level:4},{value:"OffRamps",id:"offramps",level:4},{value:"Token pools",id:"token-pools",level:4},{value:"Risk Management Network",id:"risk-management-network",level:4},{value:"Creating a project",id:"creating-a-project",level:2},{value:"Installing Chainlink smart contracts",id:"installing-chainlink-smart-contracts",level:2},{value:"Writing the smart contracts",id:"writing-the-smart-contracts",level:2},{value:"Creating a Sender contract",id:"creating-a-sender-contract",level:3},{value:"Code walkthrough",id:"code-walkthrough",level:4},{value:"Initializing the contract",id:"initializing-the-contract",level:5},{value:"Sending a message",id:"sending-a-message",level:5},{value:"Creating a Receiver contract",id:"creating-a-receiver-contract",level:3},{value:"Code walkthrough",id:"code-walkthrough-1",level:4},{value:"Initializing the contract",id:"initializing-the-contract-1",level:5},{value:"Receiving a message",id:"receiving-a-message",level:5},{value:"Retrieving a message",id:"retrieving-a-message",level:5},{value:"Compiling the smart contracts",id:"compiling-the-smart-contracts",level:2},{value:"Deploying the smart contract",id:"deploying-the-smart-contract",level:2},{value:"Setting up your wallet as the deployer",id:"setting-up-your-wallet-as-the-deployer",level:3},{value:"Setting up environment variables",id:"setting-up-environment-variables",level:3},{value:"Deploying the smart contracts",id:"deploying-the-smart-contracts",level:3},{value:"Deploying the Sender contract to Base Goerli",id:"deploying-the-sender-contract-to-base-goerli",level:4},{value:"Deploying the Receiver contract to Optimism Goerli",id:"deploying-the-receiver-contract-to-optimism-goerli",level:4},{value:"Funding your smart contracts",id:"funding-your-smart-contracts",level:3},{value:"Interacting with the smart contract",id:"interacting-with-the-smart-contract",level:2},{value:"Sending data",id:"sending-data",level:3},{value:"Receiving data",id:"receiving-data",level:3},{value:"Conclusion",id:"conclusion",level:2}],d={toc:c},p="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This tutorial will guide you through the process of sending messages and tokens from a Base smart contract to another smart contract on a different chain using Chainlink's Cross-chain Interoperability Protocol (CCIP)."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"objectives"},"Objectives"),(0,r.kt)("p",null,"By the end of this tutorial you should be able to do the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Set up a smart contract project for Base using Foundry"),(0,r.kt)("li",{parentName:"ul"},"Install Chainlink CCIP as a dependency"),(0,r.kt)("li",{parentName:"ul"},"Use Chainlink CCIP within your smart contract to send messages and/or tokens to contracts on other different chains"),(0,r.kt)("li",{parentName:"ul"},"Deploy and test your smart contracts on Base testnet")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Chainlink CCIP is in an \u201cEarly Access\u201d development stage, meaning some of the functionality described within this tutorial is under development and may change in later versions.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("h3",{id:"foundry"},"Foundry"),(0,r.kt)("p",null,"This tutorial requires you to have Foundry installed."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"From the command-line (terminal), run: ",(0,r.kt)("inlineCode",{parentName:"li"},"curl -L https://foundry.paradigm.xyz | bash")),(0,r.kt)("li",{parentName:"ul"},"Then run ",(0,r.kt)("inlineCode",{parentName:"li"},"foundryup"),", to install the latest (nightly) build of Foundry")),(0,r.kt)("p",null,"For more information, see the Foundry Book ",(0,r.kt)("a",{parentName:"p",href:"https://book.getfoundry.sh/getting-started/installation"},"installation guide"),"."),(0,r.kt)("h3",{id:"coinbase-wallet"},"Coinbase Wallet"),(0,r.kt)("p",null,"In order to deploy a smart contract, you will first need a wallet. You can create a wallet by downloading the Coinbase Wallet browser extension."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Download ",(0,r.kt)("a",{parentName:"li",href:"https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad?hl=en"},"Coinbase Wallet"))),(0,r.kt)("h3",{id:"wallet-funds"},"Wallet funds"),(0,r.kt)("p",null,"For this tutorial you will need to fund your wallet with both ETH and LINK on Base Goerli and Optimism Goerli."),(0,r.kt)("p",null,"The ETH is required for covering gas fees associated with deploying smart contracts to the blockchain, and the LINK token is required to pay for associated fees when using CCIP."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"To fund your wallet with ETH on Base Goerli, visit a faucet listed on the ",(0,r.kt)("a",{parentName:"li",href:"https://docs.base.org/tools/network-faucets"},"Base Faucets")," page."),(0,r.kt)("li",{parentName:"ul"},"To fund your wallet with ETH on Optimism Goerli, visit a faucet listed on the ",(0,r.kt)("a",{parentName:"li",href:"https://docs.optimism.io/builders/tools/faucets"},"Optimism Faucets")," page."),(0,r.kt)("li",{parentName:"ul"},"To fund your wallet with LINK, visit the ",(0,r.kt)("a",{parentName:"li",href:"https://faucets.chain.link/base-testnet"},"Chainlink Faucet"),".")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"If you are interested in building on Mainnet, you will need to ",(0,r.kt)("a",{parentName:"p",href:"https://chainlinkcommunity.typeform.com/ccip-form?#ref_id=ccip_docs"},"apply for Chainlink CCIP mainnet access"),".")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"what-is-chainlink-ccip"},"What is Chainlink CCIP?"),(0,r.kt)("p",null,"Chainlink CCIP (Cross-chain Interoperability Protocol) provides a solution for sending message data and transferring tokens across different chains."),(0,r.kt)("p",null,"The primary way for users to interface with Chainlink CCIP is through smart contracts known as ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/ccip/architecture#router"},"Routers"),". A Router contract is responsible for initiating cross-chain interactions."),(0,r.kt)("p",null,"Users can interact with ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/ccip/architecture#router"},"Routers")," to perform the following cross-chain capabilities:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Capability"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Description"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Supported receivers"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Arbitrary messaging"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Send arbitrary (encoded) data from one chain to another."),(0,r.kt)("td",{parentName:"tr",align:"left"},"Smart contracts only")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Token transfers"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Send tokens from one chain to another."),(0,r.kt)("td",{parentName:"tr",align:"left"},"Smart contracts or EOAs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Programmable token transfers"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Send tokens and arbitrary (encoded) data from one chain to another, in a single transaction."),(0,r.kt)("td",{parentName:"tr",align:"left"},"Smart contracts only")))),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"Externally owned accounts (EOAs) on EVM blockchains are unable to receive message data, because of this, only smart contracts are supported as receivers when sending arbitrary messages or programmable token transfers. Any attempt to send a programmable token transfer (data and tokens) to an EOA, will result in only the tokens being received.")),(0,r.kt)("h3",{id:"high-level-concepts"},"High-level concepts"),(0,r.kt)("p",null,"Although ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/ccip/architecture#router"},"Routers")," are the primary interface users will interact with when using CCIP, this section will cover what happens after instructions for a cross-chain interaction are sent to a Router."),(0,r.kt)("h4",{id:"onramps"},"OnRamps"),(0,r.kt)("p",null,"Once a Router receives an instruction for a cross-chain interaction, it passes it on to another contract known as an ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/ccip/architecture#onramp"},"OnRamp"),". OnRamps are responsible for a variety of tasks, including: verifying message size and gas limits, preserving the sequencing of messages, managing any fee payments, and interacting with the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/ccip/architecture#token-pools"},"token pool")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"lock")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"burn")," tokens if a token transfer is being made."),(0,r.kt)("h4",{id:"offramps"},"OffRamps"),(0,r.kt)("p",null,"The destination chain will have a contract known as an ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/ccip/architecture#offramp"},"OffRamp"),". OffRamps are responsible for a variety of tasks, including: ensuring the authenticity of a message, making sure each transaction is only executed once, and transmitting received messages to the Router contract on the destination chain."),(0,r.kt)("h4",{id:"token-pools"},"Token pools"),(0,r.kt)("p",null,"A ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/ccip/architecture#token-pools"},"token pool")," is an abstraction layer over ERC-20 tokens that facilitates OnRamp and OffRamp token-related operations. They are configured to use either a ",(0,r.kt)("inlineCode",{parentName:"p"},"Lock and Unlock")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Burn and Mint")," mechanism, depending on the type of token."),(0,r.kt)("p",null,"For example, because blockchain-native gas tokens (i.e. ETH, MATIC, AVAX) can only be minted on their native chains, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Lock and Mint")," mechanism must be used. This mechanism locks the token at the source chain, and mints a synthetic asset on the destination chain."),(0,r.kt)("p",null,"In contrast, tokens that can be minted on multiple chains (i.e. USDC, USDT, FRAX, etc.), token pools can use a ",(0,r.kt)("inlineCode",{parentName:"p"},"Burn and Mint")," mechanism, where the token is burnt on the source chain and minted on the destination chain."),(0,r.kt)("h4",{id:"risk-management-network"},"Risk Management Network"),(0,r.kt)("p",null,"Between instructions for a cross-chain interaction making its way from an OnRamp on the source chain to an OffRamp on the destination chain, it will pass through the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/ccip/concepts#risk-management-network"},"Risk Management Network"),"."),(0,r.kt)("p",null,"The Risk Management Network is a secondary validation service built using a variety of offchain and onchain components, with the responsibilities of monitoring all chains against abnormal activities."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"A deep-dive on the technical details of each of these components is too much to cover in this tutorial, but if interested you can learn more by visiting the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/ccip/architecture"},"Chainlink documentation"),".")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"creating-a-project"},"Creating a project"),(0,r.kt)("p",null,"Before you begin, you need to set up your smart contract development environment. You can setup a development environment using tools like ",(0,r.kt)("a",{parentName:"p",href:"/tools/hardhat"},"Hardhat")," or ",(0,r.kt)("a",{parentName:"p",href:"/tools/foundry"},"Foundry"),". For this tutorial you will use Foundry."),(0,r.kt)("p",null,"To create a new Foundry project, first create a new directory:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"mkdir myproject\n")),(0,r.kt)("p",null,"Then run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd myproject\nforge init\n")),(0,r.kt)("p",null,"This will create a Foundry project with the following basic layout:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},".\n\u251c\u2500\u2500 foundry.toml\n\u251c\u2500\u2500 script\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 test\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"You can delete the ",(0,r.kt)("inlineCode",{parentName:"p"},"src/Counter.sol"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"test/Counter.t.sol"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"script/Counter.s.sol")," boilerplate files that were generated with the project, as you will not be needing them.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"installing-chainlink-smart-contracts"},"Installing Chainlink smart contracts"),(0,r.kt)("p",null,"To use Chainlink CCIP within your Foundry project, you need to install Chainlink CCIP smart contracts as a project dependency using ",(0,r.kt)("inlineCode",{parentName:"p"},"forge install"),"."),(0,r.kt)("p",null,"To install Chainlink CCIP smart contracts, run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"forge install smartcontractkit/ccip --no-commit\n")),(0,r.kt)("p",null,"Once installed, update your ",(0,r.kt)("inlineCode",{parentName:"p"},"foundry.toml")," file by appending the following line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"remappings = ['@chainlink/contracts-ccip/=lib/ccip/contracts']\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"writing-the-smart-contracts"},"Writing the smart contracts"),(0,r.kt)("p",null,"The most basic use case for Chainlink CCIP is to send data and/or tokens between smart contracts on different blockchains."),(0,r.kt)("p",null,"To accomplish this, in this tutorial, you will need to create two separate smart contracts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Sender")," contract: A smart contract that interacts with CCIP to send data and tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Receiver")," contract: A smart contract that interacts with CCIP to receive data and tokens.")),(0,r.kt)("h3",{id:"creating-a-sender-contract"},"Creating a Sender contract"),(0,r.kt)("p",null,"The code snippet below is for a basic smart contract that uses CCIP to send data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'pragma solidity ^0.8.0;\n\nimport {IRouterClient} from "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol";\nimport {OwnerIsCreator} from "@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol";\nimport {Client} from "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";\nimport {IERC20} from "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";\n\ncontract Sender is OwnerIsCreator {\n\n   IRouterClient private router;\n   IERC20 private linkToken;\n\n   /// @notice Initializes the contract with the router and LINK token address.\n   /// @param _router The address of the router contract.\n   /// @param _link The address of the link contract.\n   constructor(address _router, address _link) {\n       router = IRouterClient(_router);\n       linkToken = IERC20(_link);\n   }\n\n   /// @notice Sends data to receiver on the destination chain.\n   /// @param destinationChainSelector The identifier (aka selector) for the destination blockchain.\n   /// @param receiver The address of the recipient on the destination blockchain.\n   /// @param text The string text to be sent.\n   /// @return messageId The ID of the message that was sent.\n   function sendMessage(\n       uint64 destinationChainSelector,\n       address receiver,\n       string calldata text\n   ) external onlyOwner returns (bytes32 messageId) {\n       Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\n           receiver: abi.encode(receiver), // Encode receiver address\n           data: abi.encode(text), // Encode text to send\n           tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent\n           extraArgs: Client._argsToBytes(\n               Client.EVMExtraArgsV1({gasLimit: 200_000}) // Set gas limit\n           ),\n           feeToken: address(linkToken) // Set the LINK as the feeToken address\n       });\n\n       // Get the fee required to send the message\n       uint256 fees = router.getFee(\n           destinationChainSelector,\n           message\n       );\n\n       // Revert if contract does not have enough LINK tokens for sending a message\n       require(linkToken.balanceOf(address(this)) > fees, "Not enough LINK balance");\n\n       // Approve the Router to transfer LINK tokens on contract\'s behalf in order to pay for fees in LINK\n       linkToken.approve(address(router), fees);\n\n       // Send the message through the router\n       messageId = router.ccipSend(destinationChainSelector, message);\n\n       // Return the messageId\n       return messageId;\n   }\n}\n')),(0,r.kt)("p",null,"Create a new file under your project's ",(0,r.kt)("inlineCode",{parentName:"p"},"src/")," directory named ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender.sol")," and copy the code above into the file."),(0,r.kt)("h4",{id:"code-walkthrough"},"Code walkthrough"),(0,r.kt)("p",null,"The sections below provide a detailed explanation for the code for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," contract provided above."),(0,r.kt)("h5",{id:"initializing-the-contract"},"Initializing the contract"),(0,r.kt)("p",null,"In order to send data using CCIP, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," contract will need access to the following dependencies:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"strong"},"Router")," contract"),": This contract serves as the primary interface when using CCIP to send and receive messages and tokens."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"The fee token contract"),": This contract serves as the contract for the token that will be used to pay fees when sending messages and tokens. For this tutorial, the contract address for LINK token is used.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Router")," contract address and LINK token address are passed in as parameters to the contract's constructor and stored as member variables for later for sending messages and paying any associated fees."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"contract Sender is OwnerIsCreator {\n\n   IRouterClient private router;\n   IERC20 private linkToken;\n\n   /// @notice Initializes the contract with the router and LINK token address.\n   /// @param _router The address of the router contract.\n   /// @param _link The address of the link contract.\n   constructor(address _router, address _link) {\n       router = IRouterClient(_router);\n       linkToken = IERC20(_link);\n   }\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Router")," contract provides two important methods that can be used when sending messages using CCIP:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getFee"),": Given a chain selector and message, returns the fee amount required to send the message."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ccipSend"),": Given a chain selector and message, sends the message through the router and returns an associated message ID.")),(0,r.kt)("p",null,"The next section describes how these methods are utilized to send a message to another chain."),(0,r.kt)("h5",{id:"sending-a-message"},"Sending a message"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," contract defines a custom method named ",(0,r.kt)("inlineCode",{parentName:"p"},"sendMessage")," that utilizes the methods described above in order to:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Construct a message using the ",(0,r.kt)("inlineCode",{parentName:"li"},"EVM2AnyMessage")," method provided by the ",(0,r.kt)("inlineCode",{parentName:"li"},"Client")," CCIP library, using the following data:",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"receiver"),": The receiver contract address (encoded)."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"data"),": The text data to send with the message (encoded)."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"tokenAmounts"),": The amount of tokens to send with the message. For sending just an arbitrary message this field is defined as an empty array (",(0,r.kt)("inlineCode",{parentName:"li"},"new Client.EVMTokenAmount[](0)"),"), indicating that no tokens will be sent."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"extraArgs"),": Extra arguments associated with the message, such as ",(0,r.kt)("inlineCode",{parentName:"li"},"gasLimit"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"feeToken"),": The ",(0,r.kt)("inlineCode",{parentName:"li"},"address")," of the token to be used for paying fees."))),(0,r.kt)("li",{parentName:"ol"},"Get the fees required to send the message using the ",(0,r.kt)("inlineCode",{parentName:"li"},"getFee")," method provided by the ",(0,r.kt)("inlineCode",{parentName:"li"},"Router")," contract."),(0,r.kt)("li",{parentName:"ol"},"Check that the contract holds an adequate amount of tokens to cover the fee. If not, revert the transaction."),(0,r.kt)("li",{parentName:"ol"},"Approve the ",(0,r.kt)("inlineCode",{parentName:"li"},"Router")," contract to transfer tokens on the ",(0,r.kt)("inlineCode",{parentName:"li"},"Sender")," contracts behalf in order to cover the fees."),(0,r.kt)("li",{parentName:"ol"},"Send the message to a specified chain using the ",(0,r.kt)("inlineCode",{parentName:"li"},"Router")," contract's ",(0,r.kt)("inlineCode",{parentName:"li"},"ccipSend")," method."),(0,r.kt)("li",{parentName:"ol"},"Return a unique ID associated with the sent message.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'/// @param receiver The address of the recipient on the destination blockchain.\n/// @param text The string text to be sent.\n/// @return messageId The ID of the message that was sent.\nfunction sendMessage(\n    uint64 destinationChainSelector,\n    address receiver,\n    string calldata text\n) external onlyOwner returns (bytes32 messageId) {\n    Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\n        receiver: abi.encode(receiver), // Encode receiver address\n        data: abi.encode(text), // Encode text to send\n        tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent\n        extraArgs: Client._argsToBytes(\n            Client.EVMExtraArgsV1({gasLimit: 200_000}) // Set gas limit\n        ),\n        feeToken: address(linkToken) // Set the LINK as the feeToken address\n    });\n\n    // Get the fee required to send the message\n    uint256 fees = router.getFee(\n        destinationChainSelector,\n        message\n    );\n\n    // Revert if contract does not have enough LINK tokens for sending a message\n    require(linkToken.balanceOf(address(this)) > fees, "Not enough LINK balance");\n\n    // Approve the Router to transfer LINK tokens on contract\'s behalf in order to pay for fees in LINK\n    linkToken.approve(address(router), fees);\n    // Send the message through the router\n    messageId = router.ccipSend(destinationChainSelector, message);\n\n    // Return the messageId\n    return messageId;\n}\n')),(0,r.kt)("h3",{id:"creating-a-receiver-contract"},"Creating a Receiver contract"),(0,r.kt)("p",null,"The code snippet below is for a basic smart contract that uses CCIP to receive data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'pragma solidity ^0.8.0;\n\nimport {Client} from "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";\nimport {CCIPReceiver} from "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol";\n\ncontract Receiver is CCIPReceiver {\n\n   bytes32 private _messageId;\n   string private _text;\n\n   /// @notice Constructor - Initializes the contract with the router address.\n   /// @param router The address of the router contract.\n   constructor(address router) CCIPReceiver(router) {}\n\n   /// @notice Handle a received message\n   /// @param message The cross-chain message being received.\n   function _ccipReceive(\n       Client.Any2EVMMessage memory message\n   ) internal override {\n       _messageId = message.messageId; // Store the messageId\n       _text = abi.decode(message.data, (string)); // Decode and store the message text\n   }\n\n    /// @notice Gets the last received message.\n    /// @return messageId The ID of the last received message.\n    /// @return text The last received text.\n    function getMessage()\n        external\n        view\n        returns (bytes32 messageId, string memory text)\n    {\n        return (_messageId, _text);\n    }\n}\n')),(0,r.kt)("p",null,"Create a new file under your project\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"src/")," directory named ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver.sol")," and copy the code above into the file."),(0,r.kt)("h4",{id:"code-walkthrough-1"},"Code walkthrough"),(0,r.kt)("p",null,"The sections below provide a detailed explanation for the code for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contract provided above."),(0,r.kt)("h5",{id:"initializing-the-contract-1"},"Initializing the contract"),(0,r.kt)("p",null,"In order to receive data using CCIP, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contract will need to extend to the",(0,r.kt)("inlineCode",{parentName:"p"},"CCIPReceiver")," interface. Extending this interface allows the ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contract to initialize the contract with the router address from the constructor, as seen below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'import {CCIPReceiver} from "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol";\n\ncontract Receiver is CCIPReceiver {\n\n   /// @notice Constructor - Initializes the contract with the router address.\n   /// @param router The address of the router contract.\n   constructor(address router) CCIPReceiver(router) {}\n}\n')),(0,r.kt)("h5",{id:"receiving-a-message"},"Receiving a message"),(0,r.kt)("p",null,"Extending the ",(0,r.kt)("inlineCode",{parentName:"p"},"CCIPReceiver")," interface also allows the ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contract to override the ",(0,r.kt)("inlineCode",{parentName:"p"},"_ccipReceive")," handler method for when a message is received and define custom logic."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"/// @notice Handle a received message\n/// @param message The cross-chain message being received.\nfunction _ccipReceive(\n    Client.Any2EVMMessage memory message\n) internal override {\n    // Add custom logic here\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contract in this tutorial provides custom logic that stores the ",(0,r.kt)("inlineCode",{parentName:"p"},"messageId")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"text")," (decoded) as member variables."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"contract Receiver is CCIPReceiver {\n\n   bytes32 private _messageId;\n   string private _text;\n\n   /// @notice Constructor - Initializes the contract with the router address.\n   /// @param router The address of the router contract.\n   constructor(address router) CCIPReceiver(router) {}\n\n   /// @notice Handle a received message\n   /// @param message The cross-chain message being received.\n   function _ccipReceive(\n       Client.Any2EVMMessage memory message\n   ) internal override {\n       _messageId = message.messageId; // Store the messageId\n       _text = abi.decode(message.data, (string)); // Decode and store the message text\n   }\n}\n")),(0,r.kt)("h5",{id:"retrieving-a-message"},"Retrieving a message"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contract defines a custom method named ",(0,r.kt)("inlineCode",{parentName:"p"},"getMessage")," that returns the details of the last received message ",(0,r.kt)("inlineCode",{parentName:"p"},"_messagId")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"_text"),". This method can be called to fetch the message data details after the ",(0,r.kt)("inlineCode",{parentName:"p"},"_ccipReceive")," receives a new message."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"/// @notice Gets the last received message.\n/// @return messageId The ID of the last received message.\n/// @return text The last received text.\nfunction getMessage()\n    external\n    view\n    returns (bytes32 messageId, string memory text)\n{\n    return (_messageId, _text);\n}\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"compiling-the-smart-contracts"},"Compiling the smart contracts"),(0,r.kt)("p",null,"To compile your smart contracts, run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"forge build\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"deploying-the-smart-contract"},"Deploying the smart contract"),(0,r.kt)("h3",{id:"setting-up-your-wallet-as-the-deployer"},"Setting up your wallet as the deployer"),(0,r.kt)("p",null,"Before you can deploy your smart contract to the Base network, you will need to set up a wallet to be used as the deployer."),(0,r.kt)("p",null,"To do so, you can use the ",(0,r.kt)("a",{parentName:"p",href:"https://book.getfoundry.sh/reference/cast/cast-wallet-import"},(0,r.kt)("inlineCode",{parentName:"a"},"cast wallet import"))," command to import the private key of the wallet into Foundry's securely encrypted keystore:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cast wallet import deployer --interactive\n")),(0,r.kt)("p",null,"After running the command above, you will be prompted to enter your private key, as well as a password for signing transactions."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"For instructions on how to get your private key from Coinbase Wallet, visit the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.cloud.coinbase.com/wallet-sdk/docs/developer-settings#show-private-key"},"Coinbase Wallet documentation"),". ",(0,r.kt)("strong",{parentName:"p"},"It is critical that you do NOT commit this to a public repo"),".")),(0,r.kt)("p",null,"To confirm that the wallet was imported as the ",(0,r.kt)("inlineCode",{parentName:"p"},"deployer")," account in your Foundry project, run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cast wallet list\n")),(0,r.kt)("h3",{id:"setting-up-environment-variables"},"Setting up environment variables"),(0,r.kt)("p",null,"To setup your environment, create an ",(0,r.kt)("inlineCode",{parentName:"p"},".env")," file in the home directory of your project, and add the RPC URLs, ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/ccip/supported-networks/v1_2_0/testnet"},"CCIP chain selectors"),", ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/ccip/supported-networks/v1_2_0/testnet"},"CCIP router addresses"),", and ",(0,r.kt)("a",{parentName:"p",href:"https://docs.chain.link/resources/link-token-contracts"},"LINK token addresses")," for both Base Goerli and Optimism Goerli testnets:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'BASE_GOERLI_RPC="https://goerli.base.org"\nOPTIMISM_GOERLI_RPC="https://goerli.optimism.io"\n\nBASE_GOERLI_CHAIN_SELECTOR=5790810961207155433\nOPTIMISM_GOERLI_CHAIN_SELECTOR=2664363617261496610\n\nBASE_GOERLI_ROUTER_ADDRESS="0x80AF2F44ed0469018922c9F483dc5A909862fdc2"\nOPTIMISM_GOERLI_ROUTER_ADDRESS="0xcc5a0B910D9E9504A7561934bed294c51285a78D"\n\nBASE_GOERLI_LINK_ADDRESS="0x6D0F8D488B669aa9BA2D0f0b7B75a88bf5051CD3"\nOPTIMISM_GOERLI_LINK_ADDRESS="0xdc2CC710e42857672E7907CF474a69B63B93089f"\n')),(0,r.kt)("p",null,"Once the ",(0,r.kt)("inlineCode",{parentName:"p"},".env")," file has been created, run the following command to load the environment variables in the current command line session:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"source .env\n")),(0,r.kt)("h3",{id:"deploying-the-smart-contracts"},"Deploying the smart contracts"),(0,r.kt)("p",null,"With your contracts compiled and environment setup, you are ready to deploy the smart contracts."),(0,r.kt)("p",null,"To deploy a smart contract using Foundry, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"forge create")," command. The command requires you to specify the smart contract you want to deploy, an RPC URL of the network you want to deploy to, and the account you want to deploy with."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Your wallet must be funded with ETH on the Base Goerli and Optimism Goerli to cover the gas fees associated with the smart contract deployment. Otherwise, the deployment will fail."),(0,r.kt)("p",{parentName:"admonition"},"To get testnet ETH for Base Goerli and Optimism Goerli, see the ",(0,r.kt)("a",{parentName:"p",href:"#prerequisites"},"prerequisites"),".")),(0,r.kt)("h4",{id:"deploying-the-sender-contract-to-base-goerli"},"Deploying the Sender contract to Base Goerli"),(0,r.kt)("p",null,"To deploy the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," smart contract to the Base Goerli testnet, run the following command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"forge create ./src/Sender.sol:Sender --rpc-url $BASE_GOERLI_RPC --constructor-args $BASE_GOERLI_ROUTER_ADDRESS $BASE_GOERLI_LINK_ADDRESS --account deployer\n")),(0,r.kt)("p",null,"When prompted, enter the password that you set earlier, when you imported your wallet's private key."),(0,r.kt)("p",null,"After running the command above, the contract will be deployed on the Base Goerli test network. You can view the deployment status and contract by using a ",(0,r.kt)("a",{parentName:"p",href:"/tools/block-explorers"},"block explorer"),"."),(0,r.kt)("h4",{id:"deploying-the-receiver-contract-to-optimism-goerli"},"Deploying the Receiver contract to Optimism Goerli"),(0,r.kt)("p",null,"To deploy the ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," smart contract to the Optimism Goerli testnet, run the following command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"forge create ./src/Receiver.sol:Receiver --rpc-url $OPTIMISM_GOERLI_RPC --constructor-args $OPTIMISM_GOERLI_ROUTER_ADDRESS --account deployer\n")),(0,r.kt)("p",null,"When prompted, enter the password that you set earlier, when you imported your wallet's private key."),(0,r.kt)("p",null,"After running the command above, the contract will be deployed on the Optimism Goerli test network. You can view the deployment status and contract by using the ",(0,r.kt)("a",{parentName:"p",href:"https://goerli-optimism.etherscan.io/"},"OP Goerli block explorer"),"."),(0,r.kt)("h3",{id:"funding-your-smart-contracts"},"Funding your smart contracts"),(0,r.kt)("p",null,"In order to pay for the fees associated with sending messages, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," contract will need to hold a balance of LINK tokens."),(0,r.kt)("p",null,"Fund your contract directly from your wallet, or by running the following ",(0,r.kt)("inlineCode",{parentName:"p"},"cast")," command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'cast send $BASE_GOERLI_LINK_ADDRESS --rpc-url $BASE_GOERLI_RPC "transfer(address,uint256)" <SENDER_CONTRACT_ADDRESS> 5 --account deployer\n')),(0,r.kt)("p",null,"The above command sends ",(0,r.kt)("inlineCode",{parentName:"p"},"5")," LINK tokens on Base Goerli testnet to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," contract."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Replace ",(0,r.kt)("inlineCode",{parentName:"p"},"<SENDER_CONTRACT_ADDRESS>")," with the contract address of your deployed ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," contract before running the provided ",(0,r.kt)("inlineCode",{parentName:"p"},"cast")," command.")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"interacting-with-the-smart-contract"},"Interacting with the smart contract"),(0,r.kt)("p",null,"Foundry provides the ",(0,r.kt)("inlineCode",{parentName:"p"},"cast")," command-line tool that can be used to interact with deployed smart contracts and call their functions."),(0,r.kt)("h3",{id:"sending-data"},"Sending data"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"cast")," command can be used to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"sendMessage(uint64, address, string)")," function on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," contract deployed to Base Goerli in order to send message data to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contract on Optimism Goerli."),(0,r.kt)("p",null,"To call the ",(0,r.kt)("inlineCode",{parentName:"p"},"sendMessage(uint64, address, string)")," function of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," smart contract, run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'cast send <SENDER_CONTRACT_ADDRESS> --rpc-url $BASE_GOERLI_RPC "sendMessage(uint64, address, string)" $OPTIMISM_GOERLI_CHAIN_SELECTOR <RECEIVER_CONTRACT_ADDRESS> "Based" --account deployer\n')),(0,r.kt)("p",null,"The command above calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"sendMessage(uint64, address, string)")," to send a message. The parameters passed in to the method include: The chain selector to the destination chain (Optimism Goerli), the ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contract address, and the text data to be included in the message (",(0,r.kt)("inlineCode",{parentName:"p"},"Based"),")."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Replace ",(0,r.kt)("inlineCode",{parentName:"p"},"<SENDER_CONTRACT_ADDRESS>")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"<RECEIVER_CONTRACT_ADDRESS>")," with the contract addresses of your deployed ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contracts respectively before running the provided ",(0,r.kt)("inlineCode",{parentName:"p"},"cast")," command.")),(0,r.kt)("p",null,"After running the command, a unique ",(0,r.kt)("inlineCode",{parentName:"p"},"messageId")," should be returned."),(0,r.kt)("p",null,"Once the transaction has been finalized, it will take a few minutes for CCIP to deliver the data to Optimism Goerli and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"ccipReceive")," function on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contract."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"You can use the ",(0,r.kt)("a",{parentName:"p",href:"https://ccip.chain.link/"},"CCIP explorer")," to see the status of the CCIP transaction.")),(0,r.kt)("h3",{id:"receiving-data"},"Receiving data"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"cast")," command can also be used to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"getMessage()")," function on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contract deployed to Optimism Goerli in order to read the received message data."),(0,r.kt)("p",null,"To call the ",(0,r.kt)("inlineCode",{parentName:"p"},"getMessage()")," function of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," smart contract, run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'cast send <RECEIVER_CONTRACT_ADDRESS> --rpc-url $OPTIMISM_GOERLI_RPC "getMessage()" --account deployer\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Replace ",(0,r.kt)("inlineCode",{parentName:"p"},"<RECEIVER_CONTRACT_ADDRESS>")," with the contract addresses of your deployed ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver")," contract before running the provided ",(0,r.kt)("inlineCode",{parentName:"p"},"cast")," command.")),(0,r.kt)("p",null,"After running the command, the ",(0,r.kt)("inlineCode",{parentName:"p"},"messageId")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"text")," of the last received message should be returned."),(0,r.kt)("p",null,"If the transaction fails, ensure the status of your ",(0,r.kt)("inlineCode",{parentName:"p"},"ccipSend")," transaction has been finalized. You can using the ",(0,r.kt)("a",{parentName:"p",href:"https://ccip.chain.link/"},"CCIP explorer"),"."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"Congratulations! You have successfully learned how to perform cross-chain messaging on Base using Chainlink CCIP."),(0,r.kt)("p",null,"To learn more about cross-chain messaging and Chainlink CCIP, check out the following resources:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.base.org/tools/cross-chain"},"Cross-chain")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.chain.link/ccip"},"Chainlink CCIP"))),(0,r.kt)("hr",null))}h.isMDXComponent=!0}}]);