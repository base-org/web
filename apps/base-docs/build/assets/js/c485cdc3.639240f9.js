"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[9965],{30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),d=a,h=c["".concat(l,".").concat(d)]||c[d]||m[d]||i;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},98404:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var r=n(7896),a=(n(2784),n(30876));const i={title:"Structs",description:"Practice using structs.",hide_table_of_contents:!1},o=void 0,s={unversionedId:"docs/structs/structs-sbs",id:"docs/structs/structs-sbs",title:"Structs",description:"Practice using structs.",source:"@site/base-camp/docs/structs/structs-sbs.md",sourceDirName:"docs/structs",slug:"/docs/structs/structs-sbs",permalink:"/base-camp/docs/structs/structs-sbs",draft:!1,tags:[],version:"current",frontMatter:{title:"Structs",description:"Practice using structs.",hide_table_of_contents:!1},sidebar:"docs",previous:{title:"Structs",permalink:"/base-camp/docs/structs/structs-vid"},next:{title:"Structs Exercise",permalink:"/base-camp/docs/structs/structs-exercise"}},l={},u=[{value:"Objectives",id:"objectives",level:2},{value:"Creating a Struct",id:"creating-a-struct",level:2},{value:"Setting up the Struct",id:"setting-up-the-struct",level:3},{value:"Instantiating a Struct with Its Name",id:"instantiating-a-struct-with-its-name",level:3},{value:"Saving Multiple Instances to Storage",id:"saving-multiple-instances-to-storage",level:3},{value:"Unexpected Behavior in Structs",id:"unexpected-behavior-in-structs",level:2},{value:"Dynamic Storage Arrays in Structs",id:"dynamic-storage-arrays-in-structs",level:3},{value:"Mappings Inside of Structs",id:"mappings-inside-of-structs",level:3},{value:"Automatic Getters for Public Structs",id:"automatic-getters-for-public-structs",level:3},{value:"Conclusion",id:"conclusion",level:2}],p={toc:u},c="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," type allows you to organize related data of different types."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"objectives"},"Objectives"),(0,a.kt)("p",null,"By the end of this lesson you should be able to:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Construct a ",(0,a.kt)("inlineCode",{parentName:"li"},"struct")," (user-defined type) that contains several different data types"),(0,a.kt)("li",{parentName:"ul"},"Declare members of the ",(0,a.kt)("inlineCode",{parentName:"li"},"struct")," to maximize storage efficiency"),(0,a.kt)("li",{parentName:"ul"},"Describe constraints related to the assignment of ",(0,a.kt)("inlineCode",{parentName:"li"},"struct"),"s depending on the types they contain")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"creating-a-struct"},"Creating a Struct"),(0,a.kt)("p",null,"In the last exercise, we used a ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," to create a relationship between an ",(0,a.kt)("inlineCode",{parentName:"p"},"address")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"uint"),". But what if your users have favorite colors too? Or favorite cars? You ",(0,a.kt)("strong",{parentName:"p"},"could")," create a ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," for each of these, but it would quickly get awkward. Instead, a ",(0,a.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/types.html#structs"},(0,a.kt)("inlineCode",{parentName:"a"},"struct"))," can be used to create a custom type that can store all of a user's favorites within one data type."),(0,a.kt)("p",null,"Create a new contract called ",(0,a.kt)("inlineCode",{parentName:"p"},"Structs"),"."),(0,a.kt)("h3",{id:"setting-up-the-struct"},"Setting up the Struct"),(0,a.kt)("p",null,"Instantiate a ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," with the keyword, followed by a name for the type, curly brackets, and the variables that make up the type. Add a stub for ",(0,a.kt)("inlineCode",{parentName:"p"},"Favorites"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Favorites {\n\n}\n")),(0,a.kt)("p",null,"After consulting with the designers, we need to store the following for each address's favorites:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Favorite number"),(0,a.kt)("li",{parentName:"ul"},"Birth Day of Month"),(0,a.kt)("li",{parentName:"ul"},"Favorite color"),(0,a.kt)("li",{parentName:"ul"},"Lucky Lottery numbers")),(0,a.kt)("p",null,"Let's pause for a moment and do some technical design around how to save our favorites."),(0,a.kt)("p",null,"The product team has confirmed for us that we can safely expect that no users have a favorite number greater than 65,536, and of course, everyone is born on a day of the month between 1-31."),(0,a.kt)("p",null,"Variable ",(0,a.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html"},"packing")," also works inside structs, so we could potentially save on storage by using smaller ",(0,a.kt)("inlineCode",{parentName:"p"},"uint"),"s for those variables. However, people don't change their favorite number very often, and the day of the month that they were born on never changes."),(0,a.kt)("p",null,"Therefore, it's probably more gas-efficient and less cumbersome to write other parts of the code, if we just use ",(0,a.kt)("inlineCode",{parentName:"p"},"uint")," for both variables."),(0,a.kt)("p",null,"Favorite color can be a ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,a.kt)("p",null,"For Lucky Lottery Numbers, we need a collection. We could use a dynamic array, since this will be in ",(0,a.kt)("em",{parentName:"p"},"storage"),", but we already know that the lottery has 5 numbers."),(0,a.kt)("p",null,"Try to use this information to build the ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," on your own. You should end up with something similar to:"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Reveal code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Favorites {\n    uint favoriteNumber;\n    uint birthDay;\n    string favoriteColor;\n    uint[5] lotteryNumbers;\n}\n"))),(0,a.kt)("br",null),(0,a.kt)("h3",{id:"instantiating-a-struct-with-its-name"},"Instantiating a Struct with Its Name"),(0,a.kt)("p",null,"There are two ways to instantiate a struct using its name. The first is similar to instantiating a new object in JavaScript:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'Favorites memory myFavorites = Favorites({\n    favoriteNumber: 29,\n    birthDay: 14,\n    favoriteColor: "red",\n    lotteryNumbers: [uint(1), 2, 3, 4, 5]\n});\n')),(0,a.kt)("p",null,"You can also use a shorthand method where you skip the member names and just list a value for each one. Note that the curly brackets are ",(0,a.kt)("strong",{parentName:"p"},"not")," included in this format:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'Favorites memory myFavorites = Favorites(\n    29,\n    14,\n    "red",\n    [uint(1), 2, 3, 4, 5]\n);\n')),(0,a.kt)("p",null,"There's no difference in gas costs with either of these methods. Use the one that makes the most sense for the given situation."),(0,a.kt)("h3",{id:"saving-multiple-instances-to-storage"},"Saving Multiple Instances to Storage"),(0,a.kt)("p",null,"Next, we need to figure out the best way to organize the ",(0,a.kt)("inlineCode",{parentName:"p"},"Favorites")," in ",(0,a.kt)("em",{parentName:"p"},"storage"),". There are a few options, as always, each with tradeoffs. You could match the pattern you used for favorite numbers and utilize a ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," to match ",(0,a.kt)("inlineCode",{parentName:"p"},"addresses")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"Favorites"),"."),(0,a.kt)("p",null,"Another popular method is to use an array, which takes advantage of ",(0,a.kt)("inlineCode",{parentName:"p"},".push")," returning a reference to the newly added element, and the fact that the concept of ",(0,a.kt)("em",{parentName:"p"},"undefined")," does not exist in Solidity."),(0,a.kt)("p",null,"First, instantiate an array of ",(0,a.kt)("inlineCode",{parentName:"p"},"Favorites"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"Favorites[] public userFavorites;\n")),(0,a.kt)("p",null,"Next, add a ",(0,a.kt)("inlineCode",{parentName:"p"},"public")," function to add submitted favorites to the list. It should take each of the members as an argument. Then, assign each argument to the new element via the reference returned by ",(0,a.kt)("inlineCode",{parentName:"p"},"push()"),"."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Reveal code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function addFavorite(\n    uint _favoriteNumber,\n    uint _birthDay,\n    string calldata _favoriteColor,\n    uint[5] calldata _lotteryNumbers\n) public {\n    // .push() returns a reference to the new element\n    Favorites storage newFavorite = userFavorites.push();\n    newFavorite.favoriteNumber = _favoriteNumber;\n    newFavorite.birthDay = _birthDay;\n    newFavorite.favoriteColor = _favoriteColor;\n    newFavorite.lotteryNumbers = _lotteryNumbers;\n}\n"))),(0,a.kt)("br",null),(0,a.kt)("p",null,"Alternatively, you can create an instance in memory, then ",(0,a.kt)("inlineCode",{parentName:"p"},"push")," it to storage."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Reveal code"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'function addFavorite(\n    uint _favoriteNumber,\n    uint _birthDay,\n    string calldata _favoriteColor,\n    uint[5] calldata _lotteryNumbers\n) public {\n    Favorites memory myFavorites = Favorites(\n        29,\n        14,\n        "red",\n        [uint(1), 2, 3, 4, 5]\n    );\n\n    userFavorites.push(myFavorites);\n}\n'))),(0,a.kt)("br",null),(0,a.kt)("p",null,"The gas cost is similar for each of these methods."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"unexpected-behavior-in-structs"},"Unexpected Behavior in Structs"),(0,a.kt)("p",null,"Structs in Solidity exhibit some properties that are unexpected, or even frustrating. Working with them often includes untangling a set of mutually-exclusive properties and needs."),(0,a.kt)("h3",{id:"dynamic-storage-arrays-in-structs"},"Dynamic Storage Arrays in Structs"),(0,a.kt)("p",null,"The product team has contacted you to let you know that the beta testers are complaining about the ",(0,a.kt)("inlineCode",{parentName:"p"},"lotteryNumbers"),". As it turns out, not every locality has lotteries where 5 numbers are drawn. Some have 3, 4, or even 6!."),(0,a.kt)("p",null,"You might think this is an easy enough change. After all, you can just remove the size from the array declaration inside ",(0,a.kt)("inlineCode",{parentName:"p"},"Favorites"),". Go ahead and try it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"struct Favorites {\n    uint favoriteNumber;\n    uint birthDay;\n    string favoriteColor;\n    uint[] lotteryNumbers; // Removed the '5'\n}\n")),(0,a.kt)("p",null,"You'll get an error if you're using the ",(0,a.kt)("inlineCode",{parentName:"p"},"memory")," method shown above."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"from solidity:\nTypeError: Invalid type for argument in function call. Invalid implicit conversion from uint256[5] memory to uint256[] memory requested.\n  --\x3e contracts/mappings_exercise.sol:70:13:\n   |\n70 |             [uint(1), 2, 3, 4, 5]\n   |             ^^^^^^^^^^^^^^^^^^^^^\n")),(0,a.kt)("p",null,"The simplest resolution here is to switch back to using ",(0,a.kt)("inlineCode",{parentName:"p"},"push()")," to create an empty instance of ",(0,a.kt)("inlineCode",{parentName:"p"},"Favorites"),", then assigning the values."),(0,a.kt)("p",null,"The reason this works is a little obtuse. In the failing example, an unsized ",(0,a.kt)("inlineCode",{parentName:"p"},"uint")," array is the expected type for the argument, but a sized ",(0,a.kt)("inlineCode",{parentName:"p"},"uint")," array is provided. Solidity cannot perform implicit conversions like this most of the time and you'll get a compiler error if you provide the wrong type for an argument, even if it is convertible."),(0,a.kt)("p",null,"One exception to this rule is that Solidity ",(0,a.kt)("strong",{parentName:"p"},"can")," perform an implicit conversion during ",(0,a.kt)("em",{parentName:"p"},"assignment"),' if the variable on the right side "fits" into the variable on the left side.'),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"uint[5]")," fits in ",(0,a.kt)("inlineCode",{parentName:"p"},"uint[]"),", so Solidity will allow it to sit \ud83d\udc08."),(0,a.kt)("p",null,"But what happens if you use the ",(0,a.kt)("em",{parentName:"p"},"getter")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"userFavorites")," to retrieve your entry?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'{\n    "0": "uint256: favoriteNumber 29",\n    "1": "uint256: birthDay 14",\n    "2": "string: favoriteColor red"\n}\n')),(0,a.kt)("p",null,"What happened to the array? It's not there, and it turns out that this is ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ethereum/solidity/issues/1626"},"on purpose"),"."),(0,a.kt)("h3",{id:"mappings-inside-of-structs"},"Mappings Inside of Structs"),(0,a.kt)("p",null,"You may add ",(0,a.kt)("inlineCode",{parentName:"p"},"mappings")," inside of ",(0,a.kt)("inlineCode",{parentName:"p"},"struct"),"s, subject to a few quirks and restrictions. Add ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping (uint => uint) numberPairs;")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"Favorites"),"."),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"addFavorites"),", assign ",(0,a.kt)("inlineCode",{parentName:"p"},"newFavorite.numberPairs[33] = 66;")),(0,a.kt)("p",null,"Deploy and test. So far, so good!"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"D\xe9j\xe0 vu")," ahead: But what happens if you use the ",(0,a.kt)("em",{parentName:"p"},"getter")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"userFavorites")," to retrieve your entry?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'{\n    "0": "uint256: favoriteNumber 29",\n    "1": "uint256: birthDay 14",\n    "2": "string: favoriteColor red"\n}\n')),(0,a.kt)("p",null,"It's not there, and it turns out that this is ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ethereum/solidity/issues/1626"},"on purpose"),"."),(0,a.kt)("p",null,"Another issue emerges if you try to return the struct from a public function. What if you wanted your ",(0,a.kt)("inlineCode",{parentName:"p"},"addFavorite")," function to return a reference to the new favorite?"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// Bad code example, will not work\nfunction addFavorite(\n    uint _favoriteNumber,\n    uint _birthDay,\n    string calldata _favoriteColor,\n    uint[] calldata _lotteryNumbers\n) public returns (newFavorite memory) {\n    // .push() returns a reference to the new element\n    Favorites storage newFavorite = userFavorites.push();\n    newFavorite.favoriteNumber = _favoriteNumber;\n    newFavorite.birthDay = _birthDay;\n    newFavorite.favoriteColor = _favoriteColor;\n    newFavorite.lotteryNumbers = _lotteryNumbers;\n    newFavorite.numberPairs[33] = 66;\n\n    return newFavorite;\n}\n")),(0,a.kt)("p",null,"You'll get an error. The ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping")," type cannot be returned by a ",(0,a.kt)("inlineCode",{parentName:"p"},"public")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"external")," function, so neither can a ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," that contains one."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"from solidity:\nTypeError: Types containing (nested) mappings can only be parameters or return variables of internal or library functions.\n  --\x3e contracts/mappings_exercise.sol:64:23:\n   |\n64 |     ) public returns (Favorites memory) {\n   |                       ^^^^^^^^^^^^^^^^\n")),(0,a.kt)("p",null,"Finally, what happens if you try to assign ",(0,a.kt)("inlineCode",{parentName:"p"},"newFavorite")," to a ",(0,a.kt)("inlineCode",{parentName:"p"},"memory")," variable? Again, an error occurs because ",(0,a.kt)("inlineCode",{parentName:"p"},"mapping"),"s can only be in ",(0,a.kt)("inlineCode",{parentName:"p"},"storage"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// Bad code example, will not work\nFavorites memory secondFavorite = newFavorite;\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"from solidity:\nTypeError: Type struct Structs.Favorites memory is only valid in storage because it contains a (nested) mapping.\n  --\x3e contracts/mappings_exercise.sol:82:9:\n   |\n82 |         Favorites memory secondFavorite = newFavorite;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n")),(0,a.kt)("h3",{id:"automatic-getters-for-public-structs"},"Automatic Getters for Public Structs"),(0,a.kt)("p",null,"As with other types, if you put a ",(0,a.kt)("inlineCode",{parentName:"p"},"public")," ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," in storage at the contract level, the compiler will generate a getter automatically. However, these don't work quite the way you might expect. For example, imagine:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"\nstruct MyStruct {\n    uint first;\n    uint second;\n    uint third;\n}\n\nMyStruct myStruct;\n\n")),(0,a.kt)("p",null,"The automatic getter for ",(0,a.kt)("inlineCode",{parentName:"p"},"myStruct")," will ",(0,a.kt)("strong",{parentName:"p"},"not")," be:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// Approximate example, not real code\nfunction myStruct() public view returns (MyStruct memory) {\n    return myStruct;\n}\n")),(0,a.kt)("p",null,"Instead, it returns the members individually:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"// Approximate example, not real code\nfunction myStruct() public view returns (uint, uint, uint) {\n    return (myStruct.first, myStruct.second, myStruct.third);\n}\n")),(0,a.kt)("p",null,"Create your own getter to return the data as a tuple, which will be interpreted as the appropriate type if it's called from another contract via an interface."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function getMyStruct() public view returns (MyStruct memory) {\n    return myStruct;\n}\n")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"In this lesson, you've learned how to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," keyword to create a custom type that stores related data. You've also learned three methods of instantiating them and common patterns for storing ",(0,a.kt)("inlineCode",{parentName:"p"},"struct"),"s in storage. Finally, you've explored some of the constraints that emerge when working with more complex data types within a ",(0,a.kt)("inlineCode",{parentName:"p"},"struct"),"."))}m.isMDXComponent=!0}}]);