"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[605],{30876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=c(n),h=a,m=p["".concat(s,".").concat(h)]||p[h]||d[h]||r;return n?o.createElement(m,l(l({ref:t},u),{},{components:n})):o.createElement(m,l({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[p]="string"==typeof e?e:a,l[1]=i;for(var c=2;c<r;c++)l[c]=n[c];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},78040:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var o=n(7896),a=(n(2784),n(30876));const r={title:"Hardhat: Debugging smart contracts",slug:"/hardhat-debugging",description:"A tutorial that teaches how to debug your smart contracts using Hardhat.",author:"Edson Alcala",keywords:["Hardhat","smart contract debugging","debugging logs","common errors","error resolution","decentralized applications"],tags:["smart contracts"],difficulty:"beginner",hide_table_of_contents:!1,displayed_sidebar:null},l=void 0,i={unversionedId:"docs/hardhat-debugging",id:"docs/hardhat-debugging",title:"Hardhat: Debugging smart contracts",description:"A tutorial that teaches how to debug your smart contracts using Hardhat.",source:"@site/tutorials/docs/4_hardhat-debugging.md",sourceDirName:"docs",slug:"/hardhat-debugging",permalink:"/tutorials/hardhat-debugging",draft:!1,tags:[{label:"smart contracts",permalink:"/tutorials/tags/smart-contracts"}],version:"current",sidebarPosition:4,frontMatter:{title:"Hardhat: Debugging smart contracts",slug:"/hardhat-debugging",description:"A tutorial that teaches how to debug your smart contracts using Hardhat.",author:"Edson Alcala",keywords:["Hardhat","smart contract debugging","debugging logs","common errors","error resolution","decentralized applications"],tags:["smart contracts"],difficulty:"beginner",hide_table_of_contents:!1,displayed_sidebar:null}},s={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Overview",id:"overview",level:2},{value:"Your first <code>console.log</code>",id:"your-first-consolelog",level:2},{value:"A note about <code>console.log</code>",id:"a-note-about-consolelog",level:3},{value:"Identifying common errors",id:"identifying-common-errors",level:2},{value:"Revert errors",id:"revert-errors",level:3},{value:"Unintended behavior errors",id:"unintended-behavior-errors",level:3},{value:"Out-of-bounds errors",id:"out-of-bounds-errors",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"See also",id:"see-also",level:2}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In this tutorial, you'll learn how to debug your smart contracts using the built-in debugging capabilities of Hardhat."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"objectives"},"Objectives"),(0,a.kt)("p",null,"By the end of this tutorial, you should be able to:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"console.log")," to write debugging logs"),(0,a.kt)("li",{parentName:"ul"},"List common errors and their resolutions"),(0,a.kt)("li",{parentName:"ul"},"Determine if an error is a contract error or an error in the test")),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"Debugging smart contracts can be a challenging task, especially when dealing with decentralized applications and blockchain technology. Hardhat provides powerful tools to simplify the debugging process."),(0,a.kt)("p",null,"In this tutorial, you will explore the essential debugging features offered by Hardhat and learn how to effectively identify and resolve common errors in your smart contracts."),(0,a.kt)("h2",{id:"your-first-consolelog"},"Your first ",(0,a.kt)("inlineCode",{parentName:"h2"},"console.log")),(0,a.kt)("p",null,"One of the key features of Hardhat is the ability to use ",(0,a.kt)("inlineCode",{parentName:"p"},"console.log")," for writing debugging logs in your smart contracts. In order to use it, you must include ",(0,a.kt)("inlineCode",{parentName:"p"},"hardhat/console.sol")," in the contract you wish to debug."),(0,a.kt)("p",null,"In the following contract ",(0,a.kt)("inlineCode",{parentName:"p"},"Lock.sol")," for example, you include ",(0,a.kt)("inlineCode",{parentName:"p"},"hardhat/console.sol")," by importing it and adding a few ",(0,a.kt)("inlineCode",{parentName:"p"},"console.log"),'s in the constructor with the text "Creating" and the Ether balance of the contract. This can help you not only with tracking that the contract was created successfully but also, more importantly, with the ability to include additional logs such as the balance of the contract after it was created:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport "hardhat/console.sol";\n\ncontract Lock {\n    uint256 public unlockTime;\n    address payable public owner;\n\n    constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp < _unlockTime,\n            "Unlock time should be in the future"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n\n        console.log("Creating");\n        console.log("Balance", address(this).balance);\n    }\n}\n')),(0,a.kt)("p",null,"In order to test it, you need to create a new file in the ",(0,a.kt)("inlineCode",{parentName:"p"},"test")," folder called ",(0,a.kt)("inlineCode",{parentName:"p"},"Lock.test.ts")," with the following content:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'import { expect } from "chai";\nimport { ethers } from "hardhat";\n\nimport { time } from "@nomicfoundation/hardhat-network-helpers";\nimport { SignerWithAddress } from \'@nomicfoundation/hardhat-ethers/signers\'\n\nimport { Lock__factory, Lock } from \'../typechain-types\'\n\ndescribe("Lock Tests", function () {\n  const UNLOCK_TIME = 10000;\n  const VALUE_LOCKED = ethers.parseEther("0.01");\n\n  let lastBlockTimeStamp: number;\n  let lockInstance: Lock;\n  let ownerSigner: SignerWithAddress\n\n  before(async () => {\n    lastBlockTimeStamp = await time.latest()\n\n    const signers = await ethers.getSigners()\n    ownerSigner = signers[0]\n\n    lockInstance = await new Lock__factory().connect(ownerSigner).deploy(lastBlockTimeStamp + UNLOCK_TIME, {\n      value: VALUE_LOCKED\n    })\n  })\n\n  it(\'should get the unlockTime value\', async () => {\n    expect(await lockInstance.unlockTime()).to.equal(lastBlockTimeStamp + UNLOCK_TIME)\n  })\n});\n')),(0,a.kt)("p",null,"Notice that a single test is included in order to get proper logs. However, you're only interested in the creation process that happens in the ",(0,a.kt)("inlineCode",{parentName:"p"},"before")," hook. Then, you can run:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npx hardhat test\n")),(0,a.kt)("p",null,"You should see the following in the terminal:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"  Lock\nCreating\nBalance 10000000000000000\n    \u2714 should get the unlockTime value\n")),(0,a.kt)("p",null,'The terminal shows the text "Creating" and the balance (which is 0.01 Ether) because during the creation, you are depositing Ether in the smart contract via the ',(0,a.kt)("inlineCode",{parentName:"p"},"value")," property."),(0,a.kt)("h3",{id:"a-note-about-consolelog"},"A note about ",(0,a.kt)("inlineCode",{parentName:"h3"},"console.log")),(0,a.kt)("p",null,"In the previous example, you used ",(0,a.kt)("inlineCode",{parentName:"p"},"console.log")," to include some debugging logs. Be aware that the ",(0,a.kt)("inlineCode",{parentName:"p"},"console.log")," version of Solidity is limited compared to the ones that are provided in other programming languages, where you can log almost anything."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Console.log")," can be called with up to four parameters of the following types:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"uint"),(0,a.kt)("li",{parentName:"ul"},"string"),(0,a.kt)("li",{parentName:"ul"},"bool"),(0,a.kt)("li",{parentName:"ul"},"address")),(0,a.kt)("p",null,"Hardhat includes other ",(0,a.kt)("inlineCode",{parentName:"p"},"console")," functions, such as:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"console.logInt(int i)"),(0,a.kt)("li",{parentName:"ul"},"console.logBytes(bytes memory b)"),(0,a.kt)("li",{parentName:"ul"},"console.logBytes1(bytes1 b)"),(0,a.kt)("li",{parentName:"ul"},"console.logBytes2(bytes2 b)"),(0,a.kt)("li",{parentName:"ul"},"..."),(0,a.kt)("li",{parentName:"ul"},"console.logBytes32(bytes32 b)")),(0,a.kt)("p",null,"These log functions are handy when the type you intend to log doesn't fall within the default accepted types of ",(0,a.kt)("inlineCode",{parentName:"p"},"console.log"),". For further details, refer to the official ",(0,a.kt)("a",{parentName:"p",href:"https://hardhat.org/hardhat-network/docs/reference#console.log"},"console.log")," documentation."),(0,a.kt)("h2",{id:"identifying-common-errors"},"Identifying common errors"),(0,a.kt)("p",null,"While debugging your smart contracts, it's crucial to be familiar with common errors that can arise during development. Recognizing these errors and knowing how to resolve them is an important skill."),(0,a.kt)("p",null,"In our ",(0,a.kt)("a",{parentName:"p",href:"https://base.org/camp"},"Basecamp")," series of tutorials, we cover a few compile-time errors in ",(0,a.kt)("a",{parentName:"p",href:"https://docs.base.org/base-camp/docs/error-triage"},"Error Triage"),". Other errors, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"reverts")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"index out of bounds errors")," can be unexpected during the runtime of the smart contract."),(0,a.kt)("p",null,"The following explores typical techniques to debug these types of errors."),(0,a.kt)("h3",{id:"revert-errors"},"Revert errors"),(0,a.kt)("p",null,"When a transaction fails due to a ",(0,a.kt)("inlineCode",{parentName:"p"},"require")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"revert")," statement, you'll need to diagnose why the condition isn't met and then resolve it. Typically, this involves verifying input parameters, state variables, or contract conditions."),(0,a.kt)("p",null,"The following is the ",(0,a.kt)("inlineCode",{parentName:"p"},"Lock.sol")," contract with a require statement that validates that the parameter you are passing (",(0,a.kt)("inlineCode",{parentName:"p"},"_unlockTime"),") must be greater than the current ",(0,a.kt)("inlineCode",{parentName:"p"},"block.timestamp"),"."),(0,a.kt)("p",null,"A simple solution to troubleshoot this error is to log the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"block.timestamp")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"_unlockTime"),", which will help you compare these values and then ensure that you are passing the correct ones:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport "hardhat/console.sol";\n\ncontract Lock {\n    uint public unlockTime;\n    address payable public owner;\n\n    // event Withdrawal(uint amount, uint when);\n\n    constructor(uint _unlockTime) payable {\n        console.log("_unlockTime",_unlockTime);\n        console.log("block.timestamp",block.timestamp);\n        require(\n            block.timestamp < _unlockTime,\n            "Unlock time should be in the future"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n\n        console.log("Creating");\n        console.log("Balance", address(this).balance);\n    }\n}\n')),(0,a.kt)("p",null,"When you run the tests with ",(0,a.kt)("inlineCode",{parentName:"p"},"npx hardhat test"),", you'll then see the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"Lock Tests\n_unlockTime 1697493891\nblock.timestamp 1697483892\nCreating\nBalance 10000000000000000\n    \u2714 should get the unlockTime value\n")),(0,a.kt)("p",null,"You are now able to see the ",(0,a.kt)("inlineCode",{parentName:"p"},"block.timestamp")," and the value you are passing, which makes it easier to detect the error."),(0,a.kt)("h3",{id:"unintended-behavior-errors"},"Unintended behavior errors"),(0,a.kt)("p",null,"Unintended behavior errors occur when you introduce unexpected behavior into the codebase due to a misunderstanding in the way Solidity works."),(0,a.kt)("p",null,"In the following example, ",(0,a.kt)("inlineCode",{parentName:"p"},"LockCreator")," is a contract that allows anybody to deploy a ",(0,a.kt)("inlineCode",{parentName:"p"},"Lock.sol")," instance. However, the ",(0,a.kt)("inlineCode",{parentName:"p"},"LockCreator")," contains an error: the ",(0,a.kt)("inlineCode",{parentName:"p"},"createLock")," functions are able to accept Ether to be locked but the amount sent is not being transferred to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Lock")," contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport "hardhat/console.sol";\n\nimport {Lock} from "./Lock.sol";\n\ncontract LockCreator {\n\n    Lock[] internal locks;\n\n    // Example of bad code, do not use\n    function createLock(uint256 _unlockTime) external payable {\n        Lock newLock = new Lock(_unlockTime);\n        locks.push(newLock);\n    }\n}\n')),(0,a.kt)("p",null,"You can create a test file ",(0,a.kt)("inlineCode",{parentName:"p"},"LockCreator.test.ts")," that can identify the error and then solve it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'import { ethers } from "hardhat";\n\nimport { time } from "@nomicfoundation/hardhat-network-helpers";\nimport { SignerWithAddress } from \'@nomicfoundation/hardhat-ethers/signers\'\n\nimport { LockCreator, LockCreator__factory } from \'../typechain-types\'\n\ndescribe("LockCreator Tests", function () {\n  const UNLOCK_TIME = 10000;\n  const VALUE_LOCKED = ethers.parseEther("0.01");\n\n  let lastBlockTimeStamp: number;\n  let lockInstance: LockCreator;\n  let ownerSigner: SignerWithAddress\n\n  before(async () => {\n    const signers = await ethers.getSigners()\n    ownerSigner = signers[0]\n\n    lockInstance = await new LockCreator__factory().connect(ownerSigner).deploy()\n  })\n\n  it(\'should create a lock\', async () => {\n    lastBlockTimeStamp = await time.latest()\n    await lockInstance.createLock(lastBlockTimeStamp + UNLOCK_TIME, {\n      value: VALUE_LOCKED\n    })\n  })\n});\n')),(0,a.kt)("p",null,"The following appears in the terminal where you can see the balance is ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"  LockCreator Tests\nCreating\nBalance 0\n    \u2714 should create a lock (318ms)\n")),(0,a.kt)("p",null,"Although this issue can be avoided by adding more test cases with proper assertions, the re-transfer of Ether from the ",(0,a.kt)("inlineCode",{parentName:"p"},"LockCreator")," was something you may have overlooked."),(0,a.kt)("p",null,"The solution is to modify the ",(0,a.kt)("inlineCode",{parentName:"p"},"createLock")," function with:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function createLock(uint256 _unlockTime) external payable {\n    Lock newLock = new Lock{ value: msg.value}(_unlockTime);\n    locks.push(newLock);\n}\n")),(0,a.kt)("h3",{id:"out-of-bounds-errors"},"Out-of-bounds errors"),(0,a.kt)("p",null,"Attempting to access arrays at an invalid position can also cause errors."),(0,a.kt)("p",null,"If you wish to retrieve all the ",(0,a.kt)("inlineCode",{parentName:"p"},"Lock")," contract instances being created in the previous example, you can make the ",(0,a.kt)("inlineCode",{parentName:"p"},"locks")," array public. In order to illustrate this example, though, you can create a custom function called ",(0,a.kt)("inlineCode",{parentName:"p"},"getAllLocks"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"contract LockCreator {\n    //\n    // rest of the code..\n    //\n    function getAllLocks() external view returns(Lock[] memory result) {\n        result = new Lock[](locks.length);\n        for(uint i = 0; i <= locks.length; i++){\n            result[i] = locks[i];\n        }\n    }\n}\n")),(0,a.kt)("p",null,"The function can be tested with the following test:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'describe("LockCreator Tests", function () {\n  const UNLOCK_TIME = 10000;\n  const VALUE_LOCKED = ethers.parseEther("0.01");\n\n  let lastBlockTimeStamp: number;\n  let lockInstance: LockCreator;\n  let ownerSigner: SignerWithAddress\n\n  before(async () => {\n    const signers = await ethers.getSigners()\n    ownerSigner = signers[0]\n\n    lockInstance = await new LockCreator__factory().connect(ownerSigner).deploy()\n\n    lastBlockTimeStamp = await time.latest()\n\n    await lockInstance.createLock(lastBlockTimeStamp + UNLOCK_TIME, {\n      value: VALUE_LOCKED\n    })\n  })\n\n  it(\'should get all locks\', async () => {\n    const allLocks = await lockInstance.getAllLocks()\n\n    console.log("all locks", allLocks)\n  })\n});\n')),(0,a.kt)("p",null,"Which will then throw an error:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"LockCreator Tests\nCreating\nBalance 10000000000000000\n    1) should get all locks\n\n  0 passing (3s)\n  1 failing\n\n  1) LockCreator Tests\n       should get all locks:\n     Error: VM Exception while processing transaction: reverted with panic code 0x32 (Array accessed at an out-of-bounds or negative index)\n")),(0,a.kt)("p",null,"You can include some debugging logs to identify the issue:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},' function getAllLocks() external view returns(Lock[] memory result) {\n        result = new Lock[](locks.length);\n\n        console.log("locks length %s", locks.length);\n\n        for(uint i = 0; i <= locks.length; i++){\n            console.log("Locks index %s", i);\n            result[i] = locks[i];\n        }\n}\n')),(0,a.kt)("p",null,"Then, you see the following in the terminal:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"}," LockCreator Tests\nCreating\nBalance 10000000000000000\nlocks length 1\nLocks index 0\nLocks index 1\n1) LockCreator Tests\n       should get all locks:\n     Error: VM Exception while processing transaction: reverted with panic code 0x32 (Array accessed at an out-of-bounds or negative index)\n")),(0,a.kt)("p",null,"Since arrays are 0 index based, an array with 1 item will store that item at the 0 index. In the above example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"if")," statement compares ",(0,a.kt)("inlineCode",{parentName:"p"},"<=")," against the length of the array, so it tries to access the element in position 1, and crashes."),(0,a.kt)("p",null,"Here's the simple solution:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},' function getAllLocks() external view returns(Lock[] memory result) {\n        result = new Lock[](locks.length);\n\n        console.log("locks length %s", locks.length);\n\n        for(uint i = 0; i < locks.length; i++){\n            console.log("Locks index %s", i);\n            result[i] = locks[i];\n        }\n}\n')),(0,a.kt)("p",null,"Which immediately solves the problem:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"  LockCreator Tests\nCreating\nBalance 10000000000000000\nlocks length 1\nLocks index 0\nall locks Result(1) [ '0x83BA8C2028EE8a6476396145C7692fBD09337acD' ]\n    \u2714 should get all locks\n\n\n  1 passing (3s)\n")),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"In this tutorial, you've learned some techniques about how to debug smart contracts using Hardhat. You explored some common cases of various errors and how by simply using ",(0,a.kt)("inlineCode",{parentName:"p"},"console.log")," and a proper test, you can identify and solve the problem."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"see-also"},"See also"))}d.isMDXComponent=!0}}]);