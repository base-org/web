---
title: Account Abstraction on Base using Particle Network
slug: /account-abstraction-with-particle-network
description: A walkthrough on Particle Network's Wallet Abstraction services, leveraging account abstraction and social logins across various providers.
author: TABASCOatw
keywords: [
    Account Abstraction,
    AA,
    Biconomy,
    Paymaster,
    Bundler,
    Alchemy,
    ERC-4337
    Smart account,
    Particle Network,
    Particle Connect,
    Wallet-as-a-Service,
  ]
tags: ['account abstraction']
difficulty: intermediate
displayed_sidebar: null
---

Particle Network offers Wallet Abstraction services with an Account Abstraction stack, enabling user onboarding via social logins, passkeys, or Web3 wallets.

The Particle Connect SDK supports various EVM chains, including Base, allowing 2-click integration into EOAs or SCAs.

---

## Objectives

By the end of this guide, you should be able to:

- Spin up Particle Connect project to generate an Externally-Owned-Account (EOA) via a social login
- Assign a Coinbase smart account (or alternative SCA) to the EOA generated by Particle Connect
- Facilitate 2-click logins
- Construct and execute a gasless transaction

---

## Prerequisites

### Wallet funds

This guide requires you to have ETH on Base Sepolia, which will be used to showcase the execution of a gasless transfer transaction.

- To fund your wallet with ETH on Base Sepolia, visit one of the faucets listed on the [Base Faucets] page.

### Familiarity with modern, frontend web development

In this example, you'll be building a React-based application using Next JS.

---

## Understanding Particle Network

### Wallet Abstraction

Particle Network provides a large suite of SDKs centered around the reduction of account-based friction.

In this case, "account-based friction" refers to barriers-to-entry that some Web3 users may face as they onboard into an application and begin managing a wallet.

This friction, in the context of this guide, can be placed within two distinct categories:

1. The login process. Often, decentralized applications that tend to be more consumer-facing prefer login flows that aren't dependent upon a user downloading and managing a traditional wallet, as this can be a pain point for some.
2. The rigidity of standard accounts. Externally Owned Accounts, or EOAs, are often quite rigid in how they operate. They're secured by one key and limited to a strict range of functions, thus developers (and therefore users) are confined to relatively low-level interaction with applications.

Wallet Abstraction based on Wallet-as-a-Service (WaaS) aims to solve the first of these two points, the login process. WaaS solutions provide an alternative to standard wallets, typically allowing users to use applications through accounts generated by social logins (such as Google, email, or phone). The interfaces for interacting with these accounts are also often embedded within the applications, resulting in a consistent, application-specific experience.

WaaS providers other than Particle Network include [Web3Auth], [Privy], and [Magic], among others.

### Account Abstraction

Particle Network also aims to tackle the second friction point described above: account flexibility.

Account Abstraction refers to a transition away from standard account structures, EOAs, to smart accounts. Smart accounts are contracts that act as a wallet, providing users with an account that feels equivalent to an EOA but is intrinsically programmable (due to it being a smart contract) and thus more flexible.

The most popular modern implementation of Account Abstraction is [ERC-4337], which enables Account Abstraction without any consensus-layer protocol changes. It does this through numerous components of supporting infrastructure, including a Bundler and Paymaster.

Particle Network describes its Account Abstraction stack as modular, referring to cross-compatibility with any provider of Bundlers, Paymasters, or smart accounts. Particle Network's Account Abstraction SDK runs and uses its own Bundler and Paymaster, with built-in support for [Biconomy]'s Paymaster. However, Particle has made it simple to plug into [external infrastructure and components], such as Paymasters or Bundlers from providers like Stackup or Pimlico.

#### Wallet Abstraction + Account Abstraction

Leveraging Account Abstraction directly with Wallet-as-a-Service enables users to onboard via social logins into embedded wallets that use smart accounts instead of EOAs, providing greater flexibility and user control.

Particle Connect combines these capabilities into a single SDK, simplifying the development process and enhancing the user experience.

:::info

To learn more about Account Abstraction and the concepts outlined above, see [ERC-4337], or Base’s [Introduction to Account Abstraction] guide.

:::

---

## Integrating Particle Connect

The Particle Connect SDK simplifies wallet creation, user login, and interactions with Particle. It provides a unified interface for both social logins (via Particle Auth) and traditional Web3 wallets, ensuring an accessible experience for all users, whether familiar with Web3 or not.

### Create a New Next Project

First, create a new [Next.js](https://nextjs.org/docs/getting-started/installation) project by following the instructions in the Next.js CLI. Use the default settings, enabling TypeScript and Tailwind CSS.

```sh
$ npx create-next-app@latest

What is your project named? particle-connect-app
Would you like to use TypeScript? Yes
Would you like to use ESLint? Yes
Would you like to use Tailwind CSS? Yes
Would you like your code inside a `src/` directory? Yes
Would you like to use App Router? (recommended) Yes
Would you like to customize the import alias (`@/*` by default)? No
```

### Install Dependencies

Then, install the necessary dependencies:

```sh
yarn add @particle-network/connectkit viem@^2

OR

npm install @particle-network/connectkit viem@^2
```

This command installs the latest version of the Particle Connect SDK along with Viem v2. Viem is the default library used by Particle Connect to interact with blockchain networks and send transactions.

:::info

Particle Connect comes with built-in Account Abstraction functionality, making it the only Particle package you'll need to install.

If you prefer, you can still use EIP-1193 providers like ethers, but you'll need to integrate the [Particle AA SDK](https://developers.particle.network/api-reference/aa/sdks/desktop/web) for that. For more details, refer to the [Particle Docs](https://developers.particle.network/api-reference/connect/desktop/web#use-eip-1193-provider-ethers-web3-js).
:::

### Configure Particle Connect

Once the dependencies are installed, you must create a project and an application in the Particle Dashboard to obtain the keys required for configuring Particle Connect (`projectId`, `clientKey`, and `appId`).

Steps to follow:

1. Go to the [Particle Dashboard](https://dashboard.particle.network) and login using your email.
2. Click **Add New Project** and enter a name for your project.
3. Copy and save the **Project ID** and **Client Key**.
4. Create a new application by selecting **Web** as the platform.
5. Provide a name for the application and specify the domain where it will be hosted. If you don’t have a domain, you can use any placeholder (e.g., 'base.org'); this won’t affect functionality.
6. After creating the application, copy the **App ID**.

Place the API keys in a `.env` file in the root of your project following this template:

```.env
NEXT_PUBLIC_PROJECT_ID='PROJECT_ID'
NEXT_PUBLIC_CLIENT_KEY='CLIENT_KEY'
NEXT_PUBLIC_APP_ID='APP_ID'
```

Now you are ready to configure Particle Connect. The main configuration is handled through the `ConnectKitProvider` component.

In the `src` directory, create a new file named `Connectkit.tsx` and paste the following code:

```ts
'use client';

import React from 'react';
import { ConnectKitProvider, createConfig } from '@particle-network/connectkit';
import { authWalletConnectors } from '@particle-network/connectkit/auth';
import { base, baseSepolia } from '@particle-network/connectkit/chains';

const config = createConfig({
  projectId: process.env.NEXT_PUBLIC_PROJECT_ID!,
  clientKey: process.env.NEXT_PUBLIC_CLIENT_KEY!,
  appId: process.env.NEXT_PUBLIC_APP_ID!,
  walletConnectors: [authWalletConnectors({})],

  plugins: [
    aa({
      name: 'COINBASE',
      version: '1.0.0',
    }),
  ],

  chains: [base, baseSepolia],
});

export const ParticleConnectkit = ({ children }: React.PropsWithChildren) => {
  return <ConnectKitProvider config={config}>{children}</ConnectKitProvider>;
};
```

This file now exports the `ParticleConnectKit` component, where you input the project keys and configure SDK settings.

In this example, we load the API keys from the `.env` file, enable social logins through `authWalletConnectors`, set up the `COINBASE` smart account, and restrict the available chains to Base and Base Sepolia.

Here is a breakdown:

This `config` object holds the Particle Connect SDK's settings:

- **projectId, clientKey, appId**: These values are loaded from environment variables (`.env` file).
- **walletConnectors**: This is an array of connectors representing the onboarding options you want to support within your app, in this case social login features via `authWalletConnectors`.
- **plugins**: Plugins allow to add extra configuration to the Particle embedded wallet. The `aa` plugin is used to set up a smart account.
- **chains**: The configuration restricts the supported chains to `base` (Base mainnet) and `baseSepolia` (Base Sepolia testnet).

:::info

This example provides a minimal version of the `ConnectKit.tsx` file to help you get started. For detailed configuration options and full implementation guidelines, refer to the [Particle Network documentation](https://developers.particle.network/api-reference/connect/desktop/web#configuration).
:::

### Integrate the `ParticleConnectKit` Component in Your App

With the configuration complete, the next step is to wrap your application with the `ParticleConnectKit` component to provide global access to the Particle Connect SDK. Below is an example of how to set this up in your `layout.tsx` file in `src`:

```ts
import { ParticleConnectkit } from '@/connectkit';
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Particle Connectkit App',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <ParticleConnectkit>{children}</ParticleConnectkit>
      </body>
    </html>
  );
}
```

This wraps the entire application and injects the Particle Connect configuration to the child components. All components rendered inside children will have access to the Particle Connect SDK via this provider.

### Enabling Login and Wallet Connection

After setting up Particle Connect, you can easily enable social logins and wallet connection for your application using the `ConnectButton` frontend component from the Particle ConnectKit library. Below is a basic implementation, which can be added to the `page.tsx` file located in the `src` directory:

```ts
import { ConnectButton, useAccount } from '@particle-network/connectkit';

export const App = () => {
  const { address, isConnected, chainId } = useAccount();

  return (
    <div>
      <ConnectButton />
      {isConnected && (
        <>
          <h2>Address: {address}</h2>
          <h2>Chain ID: {chainId}</h2>
        </>
      )}
    </div>
  );
};
```

Here is a code breakdown:

1. **Imports**:

   - `ConnectButton`: A pre-built button component that allows users to log into the application.

   - `useAccount`: A hook that gives access to functions and details about the connected account.

2. **Component `App`**:

   - **useAccount Hook**: Retrieves the current account's status (`isConnected`), wallet `address`, and `chainId`.
   - **Render Logic**:
     - The `ConnectButton` is rendered at all times because it will turn into an embedded widget after the user logs in.
     - Once the user is connected (i.e., `isConnected` is true), the wallet address and active chain ID are displayed.
     - The `address` represents the user’s public wallet address, and `chainId` specifies the ID of the connected blockchain network.

3. **Conditional Rendering**:
   - The `isConnected` flag ensures that the account information (address and chain ID) is only shown when a user is successfully connected. Until a connection is established, only the `ConnectButton` is visible.

To manage interactions at the application level after onboarding, `@particle-network/connectkit` offers a variety of hooks. You can explore all [available hooks](https://developers.particle.network/api-reference/connect/desktop/web#key-react-hooks-for-particle-connect) in the Particle Connect SDK documentation.

## Sending a Gasless Transaction

Particle Connect provides all the infrastructure needed to send gasless transactions easily. A gasless transaction allows users to interact with the blockchain without needing to cover gas fees. Instead, fees can be sponsored, improving user experience.

Unlike standard transactions, gasless transactions sent through ERC-4337 account abstraction use a structure called `UserOperations` (or `UserOps`).

This section will guide you through building a `UserOp`.

### Step 1: Create a Smart Account Instance

To begin, create an instance of `smartAccount`. This instance will allow you to sign transactions using the smart account and leverage the Particle Connect infrastructure for gasless operations.

```ts
import { useSmartAccount } from '@particle-network/connectkit';
import { parseEther } from 'viem'; // To be used in the transaction function

// Inside your component or app
const smartAccount = useSmartAccount();
```

#### Code Breakdown:

- **`useSmartAccount()`**: This hook provides access to the smart account instance that you'll use as the transaction signer.

---

### Step 2: Execute a Gasless Transaction

Once you have the `smartAccount` instance, you can execute a gasless transaction by constructing a `UserOperation` (also called `userOp`). Below is an example that shows how to transfer 0.01 ETH without requiring the user to pay gas fees.

```ts
const executeTxNative = async () => {
  const tx = {
    to: recipientAddress, // Recipient's address
    value: parseEther('0.01').toString(), // Amount to send (in ETH)
    data: '0x', // No additional data
  };

  // Fetch fee quotes and set up the transaction for gasless execution
  const feeQuotesResult = await smartAccount?.getFeeQuotes(tx);
  const { userOp, userOpHash } = feeQuotesResult?.verifyingPaymasterGasless || {};

  if (userOp && userOpHash) {
    const txHash = await smartAccount?.sendUserOperation({ userOp, userOpHash });
    console.log('Transaction sent:', txHash);
  }
};
```

Here is a breakdown:

- **`tx` Object**: This defines the transaction parameters.
  - `to`: The recipient's address where the 0.01 ETH will be sent.
  - `value`: The amount of ETH to transfer (in this case, 0.01 ETH). It is converted to the correct format using `parseEther` from Viem.
  - `data`: This is set to `'0x'` since there is no additional data needed for a simple transfer.
- **`getFeeQuotes(tx)`**: This method returns an array of `UserOperation` objects and hashes derived from a standard transaction object. One of the quotes returned will be the `verifyingPaymasterGasless` option, which facilitates gasless transactions by sponsoring the transaction fee.

- **`userOp` and `userOpHash`**: These values are extracted from the gasless fee quote. The `userOp` is the gasless operation to be sent, and `userOpHash` is its hash.

- **`sendUserOperation({ userOp, userOpHash })`**: This method sends the constructed gasless transaction to the network. Upon success, the `txHash` (transaction hash) is returned.

## Complete `page.tsx` File

Now that you have a solid understanding of each step, let’s bring everything together in the `page.tsx` file:

```tsx
import React, { useState } from 'react';
import { ConnectButton, useAccount, useSmartAccount } from '@particle-network/connectkit';
import { parseEther } from 'viem'; // Used to handle ETH value parsing

export const App = () => {
  const { address, isConnected, chainId } = useAccount(); // Fetch user account information
  const smartAccount = useSmartAccount(); // Initialize smart account
  const [recipientAddress, setRecipientAddress] = useState(''); // State to store recipient address
  const [transactionHash, setTransactionHash] = useState(''); // State to store transaction hash

  // Function to execute gasless transaction
  const executeTxNative = async () => {
    if (!recipientAddress) {
      alert('Please enter a recipient address');
      return;
    }

    const tx = {
      to: recipientAddress, // Recipient's address
      value: parseEther('0.01').toString(), // Amount to send (in ETH)
      data: '0x', // No additional data for a basic transfer
    };

    // Fetch fee quotes and execute the gasless transaction
    const feeQuotesResult = await smartAccount?.getFeeQuotes(tx);
    const { userOp, userOpHash } = feeQuotesResult?.verifyingPaymasterGasless || {};

    if (userOp && userOpHash) {
      const txHash = await smartAccount?.sendUserOperation({ userOp, userOpHash });
      setTransactionHash(txHash); // Set the transaction hash state
      console.log('Transaction sent:', txHash);
    } else {
      console.error('Error fetching gasless transaction details');
    }
  };

  return (
    <div>
      <ConnectButton /> {/* Button to connect wallet */}
      {isConnected && (
        <>
          <h2>Address: {address}</h2>
          <h2>Chain ID: {chainId}</h2>

          <div>
            <label>Recipient Address: </label>
            <input
              type="text"
              value={recipientAddress}
              onChange={(e) => setRecipientAddress(e.target.value)}
              placeholder="Enter recipient address"
            />
          </div>

          <button onClick={executeTxNative}>Send 0.01 ETH Gasless</button>

          {transactionHash && (
            <div>
              <h3>Transaction Hash: {transactionHash}</h3>
            </div>
          )}
        </>
      )}
    </div>
  );
};
```

### Code Breakdown:

1. **State Management**:

   - `recipientAddress`: Stores the recipient's address entered by the user.
   - `transactionHash`: Stores the hash of the executed transaction to display it later.

2. **`executeTxNative` function**:

   - Validates that a recipient address is provided.
   - Constructs the transaction object (`tx`) with the recipient's address and 0.01 ETH to be sent.
   - Fetches the gasless transaction details (`userOp` and `userOpHash`).
   - Sends the gasless transaction using `sendUserOperation` and updates the UI with the transaction hash.

3. **UI Components**:
   - **ConnectButton**: Allows users to connect to the app.
   - **Input Field**: Lets the user enter the recipient's address.
   - **Button**: Triggers the gasless transaction when clicked.
   - **Transaction Hash Display**: Shows the transaction hash after sending the transaction.

This code creates a simple interface to send gasless transactions with an input field for the recipient's address and displays the transaction hash once the transaction is sent successfully.

With everything set up, you're now ready to run your application and test it. Follow these steps:

1. Navigate to your project’s root directory.
2. Start the development server by running either `npm run dev` or `yarn dev`.
3. Once the app is running, log in using your preferred social login.
4. Fund the wallet address displayed in the bottom-right wallet modal.
5. Input the address you want to send funds to.
6. Click the **Send 0.01 ETH Gasless** button to execute a gasless transaction.

### Quickstart Guide

For a complete step-by-step guide to starting and configuring a new project with Particle Connect, check out the [Particle Connect Quickstart](https://developers.particle.network/guides/wallet-as-a-service/waas/connect/web-quickstart) in the Particle Network documentation.

## Conclusion

Congratulations! You've just built an application from scratch, onboarding users into smart accounts through social logins using Particle Network.

To learn more about using Particle Network on Base, take a look at the following resources:

- [Biconomy Guide (which uses Particle Network)]
- [Account Abstraction on Base]
- [Particle Network Documentation]
- [Particle Network 101: Developer Experience]

---

[create-react-app]: https://create-react-app.dev
[Base Faucets]: https://docs.base.org/tools/network-faucets
[Web3Auth]: https://web3auth.io
[Privy]: https://docs.base.org/tutorials/account-abstraction-with-privy-and-base-paymaster/
[Magic]: https://magic.link
[ERC-4337]: https://eips.ethereum.org/EIPS/eip-4337
[Biconomy]: https://docs.base.org/guides/account-abstraction-with-biconomy
[external infrastructure and components]: https://blog.particle.network/announcing-our-smart-wallet-as-a-service-modular-stack-upgrading-waas-with-erc-4337
[Introduction to Account Abstraction]: https://docs.base.org/tutorials/account-abstraction-with-privy-and-base-paymaster/
[Particle dashboard]: https://dashboard.particle.network
[Biconomy Guide (which uses Particle Network)]: https://docs.base.org/guides/account-abstraction-with-biconomy
[Account Abstraction on Base]: https://docs.base.org/tools/account-abstraction
[Particle Network Documentation]: https://developers.particle.network
[Particle Network 101: Developer Experience]: https://blog.particle.network/particle-network-101-developer-experience-edition
