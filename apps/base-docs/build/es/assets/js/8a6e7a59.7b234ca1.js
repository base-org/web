"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[1563],{30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=d(n),h=r,m=u["".concat(s,".").concat(h)]||u[h]||c[h]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},16471:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var a=n(7896),r=(n(2784),n(30876));const o={title:"Building onchain NFTs",slug:"/complex-onchain-nfts",description:"A tutorial that teaches how to make complex nfts that are procedurally generated and have onchain metadata and images.",author:"briandoyle81",keywords:["Solidity","ERC-721","token","NFT","SVG","generative art","onchain metadata","nft metadata","onchain images","interfaces","pseudorandom numbers","deterministic randomness"],tags:["nft"],difficulty:"intermediate",hide_table_of_contents:!1,displayed_sidebar:null},i=void 0,l={unversionedId:"docs/onchain-nfts",id:"docs/onchain-nfts",title:"Building onchain NFTs",description:"A tutorial that teaches how to make complex nfts that are procedurally generated and have onchain metadata and images.",source:"@site/tutorials/docs/2_onchain-nfts.md",sourceDirName:"docs",slug:"/complex-onchain-nfts",permalink:"/es/tutorials/complex-onchain-nfts",draft:!1,tags:[{label:"nft",permalink:"/es/tutorials/tags/nft"}],version:"current",sidebarPosition:2,frontMatter:{title:"Building onchain NFTs",slug:"/complex-onchain-nfts",description:"A tutorial that teaches how to make complex nfts that are procedurally generated and have onchain metadata and images.",author:"briandoyle81",keywords:["Solidity","ERC-721","token","NFT","SVG","generative art","onchain metadata","nft metadata","onchain images","interfaces","pseudorandom numbers","deterministic randomness"],tags:["nft"],difficulty:"intermediate",hide_table_of_contents:!1,displayed_sidebar:null}},s={},d=[{value:"Objectives",id:"objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"ERC-721 Tokens",id:"erc-721-tokens",level:3},{value:"Vector Art",id:"vector-art",level:3},{value:"Creating the Art Assets",id:"creating-the-art-assets",level:2},{value:"The Art of Making it Fit",id:"the-art-of-making-it-fit",level:2},{value:"Contract Architecture",id:"contract-architecture",level:2},{value:"Building the Contracts",id:"building-the-contracts",level:2},{value:"Overriding the <code>_baseURI()</code> Function",id:"overriding-the-_baseuri-function",level:3},{value:"Importing the Base64 Library",id:"importing-the-base64-library",level:3},{value:"Planning the override for the <code>tokenURI()</code> Function",id:"planning-the-override-for-the-tokenuri-function",level:3},{value:"Test Your Progress",id:"test-your-progress",level:3},{value:"Building the SVG",id:"building-the-svg",level:2},{value:"SVG Renderer Contract",id:"svg-renderer-contract",level:3},{value:"Rendering the Sea",id:"rendering-the-sea",level:3},{value:"Calling SeaRenderer",id:"calling-searenderer",level:3},{value:"Finishing a First Pass",id:"finishing-a-first-pass",level:2},{value:"Test Deploy",id:"test-deploy",level:3},{value:"Adding the Sky Renderer",id:"adding-the-sky-renderer",level:2},{value:"Preparing the SVG",id:"preparing-the-svg",level:3},{value:"Building the Renderer Contract",id:"building-the-renderer-contract",level:3},{value:"Incorporating the Sky Renderer",id:"incorporating-the-sky-renderer",level:3},{value:"Adding the LandRenderer",id:"adding-the-landrenderer",level:2},{value:"Preparing the SVG",id:"preparing-the-svg-1",level:3},{value:"Writing the Contract",id:"writing-the-contract",level:3},{value:"Incorporating the LandRenderer",id:"incorporating-the-landrenderer",level:3},{value:"Adding the Sun Renderer",id:"adding-the-sun-renderer",level:2},{value:"Preparing the SVGs",id:"preparing-the-svgs",level:3},{value:"Writing the Contracts",id:"writing-the-contracts",level:3},{value:"Incorporating the SunRenderer",id:"incorporating-the-sunrenderer",level:3},{value:"Adding the Cloud Renderer",id:"adding-the-cloud-renderer",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:d},u="wrapper";function c(e){let{components:t,...o}=e;return(0,r.kt)(u,(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Many NFTs are dependent on offchain metadata and images. Some use immutable storage locations, such as ",(0,r.kt)("a",{parentName:"p",href:"https://ipfs.tech/"},"IPFS"),". Others use traditional web locations, and many of these allow the owner of the contract to modify the URL returned by a contract when a site or user attempts to retrieve the location of the token art and metadata. This power isn't inherently bad, because we probably want someone to be able to fix the contract if the storage location goes down. However, it does introduce a requirement to trust the contract owner."),(0,r.kt)("p",null,"Although challenging, it is possible to write a smart contract that contains all the necessary logic and data to generate json metadata and SVG images, entirely onchain. It ",(0,r.kt)("strong",{parentName:"p"},"will")," be expensive to deploy, but will be as cheap as simpler contracts to mint!"),(0,r.kt)("p",null,"In this tutorial, we'll show you how to do this to create your own fully-onchain art project, similar to our ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/base-org/land-sea-and-sky"},"sample project"),"."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"objectives"},"Objectives"),(0,r.kt)("p",null,"By the end of this tutorial you should be able to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Programmatically generate and return json metadata for ERC-721 tokens"),(0,r.kt)("li",{parentName:"ul"},"Deterministically construct unique SVG art in a smart contract"),(0,r.kt)("li",{parentName:"ul"},"Generate deterministic, pseudorandom numbers")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("h3",{id:"erc-721-tokens"},"ERC-721 Tokens"),(0,r.kt)("p",null,"This tutorial assumes that you are able to write, test, and deploy your own ERC-721 tokens using the Solidity programming language. If you need to learn that first, check out our content in ",(0,r.kt)("a",{parentName:"p",href:"https://base.org.camp"},"Base Camp")," or the sections specific to ",(0,r.kt)("a",{parentName:"p",href:"https://docs.base.org/base-camp/docs/erc-721-token/erc-721-standard-video"},"ERC-721 Tokens"),"!"),(0,r.kt)("h3",{id:"vector-art"},"Vector Art"),(0,r.kt)("p",null,"You'll need some familiarity with the SVG art format and a basic level of ability to edit and manipulate vector art. If you don't have this, find an artist friend and collaborate!"),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"creating-the-art-assets"},"Creating the Art Assets"),(0,r.kt)("p",null,"To start, you'll need to build a few vector art assets and mock up an example of what your NFT might look like. Later, you'll cut these up and format them in a way that your smart contract will use to assemble unique NFTs for each minter."),(0,r.kt)("p",null,"The mockup needs to have all of the elements you plan to have in the NFT, and you should be able to manually move things around or change colors to make it so that you can create the range of variation you want. For example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A gradient sky in which the colors are randomized"),(0,r.kt)("li",{parentName:"ul"},"One of three styles of sun, always in the same spot in the upper right corner"),(0,r.kt)("li",{parentName:"ul"},"One to five clouds placed randomly in the upper half of the canvas"),(0,r.kt)("li",{parentName:"ul"},"A wide mountain ridge that will always be in the middle, but slide side to side to show a different part for each NFT"),(0,r.kt)("li",{parentName:"ul"},"An ocean in the foreground that is always the same")),(0,r.kt)("p",null,"If you are an artist, or are working with one, you can use the vector drawing tool of your choice to assemble your mockup. If not, you can use a number of stock art or AI tool options to assist you. If you do, make sure you understand any relevant laws or terms of service!"),(0,r.kt)("p",null,"You can also work from ours: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/base-org/land-sea-and-sky/tree/master/Final_SVGs"},"Sample Art")),(0,r.kt)("p",null,"Either way, you should end up with something similar to this:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Mockup",src:n(456).Z,width:"2222",height:"1165"})),(0,r.kt)("h2",{id:"the-art-of-making-it-fit"},"The Art of Making it Fit"),(0,r.kt)("p",null,"You'll notice that the SVG is probably way too big to be placed in a smart contract. The example is 103 KB, so you'll have to be clever to make this work."),(0,r.kt)("p",null,"You'll accomplish this task by splitting each element out of the mockup and deploying them into separate smart contracts. To do so, individually export each element, and make sure that the exported pieces are no bigger than about 15 KB. That way, you'll have enough space to fit each piece within the 24KiB limit for compiled bytecode."),(0,r.kt)("p",null,"If you're working with the sample, you'll end up with individual SVGs for:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Sun 1: 9 KB"),(0,r.kt)("li",{parentName:"ul"},"Sun 2: 9 KB"),(0,r.kt)("li",{parentName:"ul"},"Sun 3: 9 KB"),(0,r.kt)("li",{parentName:"ul"},"Ocean: 17 KB"),(0,r.kt)("li",{parentName:"ul"},"Mountain: 14 KB"),(0,r.kt)("li",{parentName:"ul"},"Cloud: 6 KB"),(0,r.kt)("li",{parentName:"ul"},"Sky: 802 bytes")),(0,r.kt)("p",null,"If you don't have the tools to do this, you can find these files here: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/base-org/land-sea-and-sky/tree/master/Final_SVGs"},"Sample Art")),(0,r.kt)("h2",{id:"contract-architecture"},"Contract Architecture"),(0,r.kt)("p",null,"You'll need to build and deploy a number of contracts for this project. They'll be organized in this architecture:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Architecture",src:n(92695).Z,width:"1416",height:"1136"})),(0,r.kt)("p",null,"Deploying this many contracts will have a cost associated with it, but once they're deployed, this contract will cost the same as any other NFT contract. Remember, ",(0,r.kt)("inlineCode",{parentName:"p"},"pure")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"view")," functions called outside the blockchain don't cost any gas. This means that you can use multiple contracts to assemble a relatively large graphic without additional costs!"),(0,r.kt)("h2",{id:"building-the-contracts"},"Building the Contracts"),(0,r.kt)("p",null,"Create a new project using the toolkit of your choice, and add a contract called ",(0,r.kt)("inlineCode",{parentName:"p"},"LandSeaSkyNFT"),". Import OpenZeppelin's ERC-721, inherit from it, and set it up with the constructor, a mint function, and a counter to keep track of the token ID:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport "hardhat/console.sol";\nimport "@openzeppelin/contracts/token/ERC721/ERC721.sol";\n\ncontract LandSeaSkyNFT is ERC721 {\n    uint public counter;\n\n    constructor() ERC721("Land, Sea, and Sky", "LSS") {}\n\n    function mint() public {\n        counter++;\n        _safeMint(msg.sender, counter);\n    }\n}\n')),(0,r.kt)("h3",{id:"overriding-the-_baseuri-function"},"Overriding the ",(0,r.kt)("inlineCode",{parentName:"h3"},"_baseURI()")," Function"),(0,r.kt)("p",null,"Normally, you'd override ",(0,r.kt)("inlineCode",{parentName:"p"},"_baseURI()")," with the base URL for the location you select to keep your NFT metadata. This could be a website, IPFS folder, or many other possible locations."),(0,r.kt)("p",null,"Since this contract will be generating the .json file directly, instead set it to indicate this to the browser:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'function _baseURI() internal pure override returns (string memory) {\n  return "data:application/json;base64,";\n}\n')),(0,r.kt)("h3",{id:"importing-the-base64-library"},"Importing the Base64 Library"),(0,r.kt)("p",null,"As indicated above, you'll be returning the json metadata in ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Base64"},"Base64")," format. OpenZeppelin has a utility contract to do this. You'll also need the ",(0,r.kt)("inlineCode",{parentName:"p"},"Strings")," library. Go ahead and import them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'import "@openzeppelin/contracts/utils/Base64.sol";\nimport "@openzeppelin/contracts/utils/Strings.sol";\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Base64 allows the transport of binary data over the web in a reliable way. It is not a compression algorithm, and actually increased the data size by a 4/3 ratio.")),(0,r.kt)("h3",{id:"planning-the-override-for-the-tokenuri-function"},"Planning the override for the ",(0,r.kt)("inlineCode",{parentName:"h3"},"tokenURI()")," Function"),(0,r.kt)("p",null,"Next, set up your ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenURI")," function override. You'll need to write some other contracts to make this work, but you can write most of the code and stub out a plan for the rest to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Check and ensure the token ID exists"),(0,r.kt)("li",{parentName:"ul"},"Compile the json metadata for the token, including:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},'"name"')," of the NFT"),(0,r.kt)("li",{parentName:"ul"},"A ",(0,r.kt)("inlineCode",{parentName:"li"},'"description"')),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},'"image"')))),(0,r.kt)("li",{parentName:"ul"},"Base64 encode the above, combine it with the ",(0,r.kt)("inlineCode",{parentName:"li"},"_baseURI")," and return it.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'function tokenURI(uint _tokenId) public view override returns (string memory) {\n  if(_tokenId > counter) {\n    revert InvalidTokenId(_tokenId); // Don\'t forget to add the error above!\n  }\n\n  string memory json = Base64.encode(\n    bytes(\n      string(\n        abi.encodePacked(\n          \'{"name": "Land, Sea, and Sky #: \',\n          Strings.toString(_tokenId),\n          \'", "description": "Land, Sea, and Sky is a collection of generative art pieces stored entirely onchain.", "image": "data:image/SVG+xml;base64,\',\n          "TODO: Build the SVG with the token ID as the seed",\n          \'"}\'\n        )\n      )\n    )\n  );\n\n  return string(abi.encodePacked(_baseURI(), json));\n}\n')),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Getting the quotes and commas correct when the json is broken apart like this is challenging. When debugging, look here first!")),(0,r.kt)("h3",{id:"test-your-progress"},"Test Your Progress"),(0,r.kt)("p",null,"Test your function by writing a simple test to mint an NFT, then call and log the output of the ",(0,r.kt)("inlineCode",{parentName:"p"},"tokenURI")," function. You should get something similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"string: data:application/json;base64,eyJuYW1lIjogIkxhbmQsIFNlYSwgYW5kIFNreSAjMSIsICJkZXNjcmlwdGlvbiI6ICJMYW5kLCBTZWEsIGFuZCBTa3kgaXMgYSBjb2xsZWN0aW9uIG9mIGdlbmVyYXRpdmUgYXJ0IHBpZWNlcyBzdG9yZWQgZW50aXJlbHkgb25jaGFpbi4iLCAiaW1hZ2UiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxUT0RPOiBCdWlsZCB0aGUgU1ZHIHdpdGggdGhlIHRva2VuIElEIGFzIHRoZSBzZWVkIn0=\n")),(0,r.kt)("p",null,"To see if it worked, you'll need to use a manual method to decode the base64 data; everything after the comma:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"eyJuYW1lIjogIkxhbmQsIFNlYSwgYW5kIFNreSAjMSIsICJkZXNjcmlwdGlvbiI6ICJMYW5kLCBTZWEsIGFuZCBTa3kgaXMgYSBjb2xsZWN0aW9uIG9mIGdlbmVyYXRpdmUgYXJ0IHBpZWNlcyBzdG9yZWQgZW50aXJlbHkgb25jaGFpbi4iLCAiaW1hZ2UiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxUT0RPOiBCdWlsZCB0aGUgU1ZHIHdpdGggdGhlIHRva2VuIElEIGFzIHRoZSBzZWVkIn0=\n")),(0,r.kt)("p",null,"You can use the terminal: ",(0,r.kt)("inlineCode",{parentName:"p"},"echo -n '<string to decode>' | base64 --decode")),(0,r.kt)("p",null,"Do so, and you'll get:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'{"name": "Land, Sea, and Sky #: 1", "description": "Land, Sea, and Sky is a collection of generative art pieces stored entirely onchain.", "image": "data:image/SVG+xml;base64,TODO: Build the SVG with the token ID as the seed"}\n')),(0,r.kt)("h2",{id:"building-the-svg"},"Building the SVG"),(0,r.kt)("p",null,"Next, you need to build logic to compile a real, working SVG from the pieces you've saved. You'll also need to add some variation based on the ID of the NFT."),(0,r.kt)("h3",{id:"svg-renderer-contract"},"SVG Renderer Contract"),(0,r.kt)("p",null,"Add a new file and contract called ",(0,r.kt)("inlineCode",{parentName:"p"},"SVGRenderer"),". It doesn't need a constructor, but it will need the ",(0,r.kt)("inlineCode",{parentName:"p"},"Strings")," library:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport "hardhat/console.sol";\nimport "@openzeppelin/contracts/utils/Strings.sol";\n\ncontract SVGRenderer {\n\n}\n')),(0,r.kt)("p",null,"Open the exemplar SVG in a code editor, and using it as an example, build out a function that uses ",(0,r.kt)("inlineCode",{parentName:"p"},"abi.encodePacked")," to build everything from the SVG ",(0,r.kt)("strong",{parentName:"p"},"except")," the actual art. That's much too big for one contract, so add stubs instead."),(0,r.kt)("p",null,"Depending on the tool you used to make the SVG, there may be unneeded extras you can remove from these lines. You also ",(0,r.kt)("strong",{parentName:"p"},"don't")," need the items in ",(0,r.kt)("inlineCode",{parentName:"p"},"<defs>")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"<styles>"),". You'll take advantage of the flexibility of the format to include those in the pieces returned by the supporting contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function render(uint _tokenId) public view returns (string memory) {\n  return string(\n    abi.encodePacked(\n      \"<SVG xmlns='http://www.w3.org/2000/SVG' viewBox='0 0 1024 1024'>\",\n      // TODO: Add the clouds,\n      // TODO: Add the sun,\n      // TODO: Add the land,\n      // TODO: Add the sea,\n      // TODO: Add the background,\n      \"</SVG>\"\n    )\n  );\n}\n")),(0,r.kt)("h3",{id:"rendering-the-sea"},"Rendering the Sea"),(0,r.kt)("p",null,"The sea element of this NFT will be the same for all NFTs, so it makes sense to write that contract first. Create it called, ",(0,r.kt)("inlineCode",{parentName:"p"},"SeaRenderer"),", with a function called ",(0,r.kt)("inlineCode",{parentName:"p"},"render"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"<g>")," element is the root of the different pieces of the SVG, so add that and a stub for the rest."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport "hardhat/console.sol";\nimport "@openzeppelin/contracts/utils/Strings.sol";\n\ncontract SeaRenderer {\n  function render() public pure returns (string memory) {\n    return // TODO: Render the sea\n  }\n}\n')),(0,r.kt)("p",null,"The next part is tricky, and a little messy. You'll need to combine parts of the individually exported SVG that has the sea art and all of its properties with the position data for this part of the art from the exemplar SVG. You'll then need to flatten it to a single line, and add it as a string constant."),(0,r.kt)("p",null,"Start by opening the Ocean SVG. Change the viewBox to ",(0,r.kt)("inlineCode",{parentName:"p"},'viewBox="0 0 1024 1024"'),". Move the ",(0,r.kt)("inlineCode",{parentName:"p"},"<defs>")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"<scripts>")," tag inside of the ",(0,r.kt)("inlineCode",{parentName:"p"},"<g>")," tag. Open the SVG in the browser to make sure it hasn't broken."),(0,r.kt)("p",null,"Next, delete the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"data-name")," from the top level ",(0,r.kt)("inlineCode",{parentName:"p"},"<g>")," and experiment with the ",(0,r.kt)("inlineCode",{parentName:"p"},'transform="translate(20,2.5)"')," property to move the art back down to the bottom of the viewport."),(0,r.kt)("p",null,"With the sample art, ",(0,r.kt)("inlineCode",{parentName:"p"},'<g transform="translate(0,700)">')," should work."),(0,r.kt)("p",null,"The last edits you need to make are ",(0,r.kt)("strong",{parentName:"p"},"critical")," - do a find/replace to change all of the ",(0,r.kt)("inlineCode",{parentName:"p"},"cls-1")," and similar classnames, to ",(0,r.kt)("inlineCode",{parentName:"p"},"cls-land-1"),"! Otherwise, the classes will override one another and nothing will be the right color. Also find all instances of ",(0,r.kt)("inlineCode",{parentName:"p"},"linear-gradient")," and do the same."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Make sure")," you change both the definitions, and where they're called!"),(0,r.kt)("p",null,"Finally, use the tool of your choice to minify ",(0,r.kt)("strong",{parentName:"p"},"only")," the outermost ",(0,r.kt)("inlineCode",{parentName:"p"},"<g>")," tag and its contents. This will flatten the code to a single line and remove extra empty character spaces. Doing so makes it easier to add to your contract, and makes the data smaller. Add it as a constant string to ",(0,r.kt)("inlineCode",{parentName:"p"},"SeaRenderer.sol"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"string constant SVG = '<g transform=\"translate(0,700)\"<way more code></g>';\n")),(0,r.kt)("p",null,"You may need to do a find/replace and ensure you're using only one type of quote in the SVG."),(0,r.kt)("p",null,"Replace your ",(0,r.kt)("inlineCode",{parentName:"p"},"TODO")," with the constant."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport "hardhat/console.sol";\nimport "@openzeppelin/contracts/utils/Strings.sol";\n\nstring constant SVG = <A very long string!>;\n\ncontract SeaRenderer {\n  function render() public pure returns (string memory) {\n    return SVG;\n  }\n}\n')),(0,r.kt)("p",null,"Test this function independently and make sure that if you paste the content inside a set of ",(0,r.kt)("inlineCode",{parentName:"p"},"<SVG>")," tags, it renders as expected!"),(0,r.kt)("h3",{id:"calling-searenderer"},"Calling SeaRenderer"),(0,r.kt)("p",null,"Return to ",(0,r.kt)("inlineCode",{parentName:"p"},"SVGRenderer.sol"),". Add an ",(0,r.kt)("inlineCode",{parentName:"p"},"interface")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"SeaRenderer"),". All of your renderer contracts will have a function called ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," that either takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"uint _tokenId"),", or no arguments, and returns a string. Because of this, you can use a single interface for all the render contracts:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"interface ISVGPartRenderer {\n  function render() external pure returns (string memory);\n  function render(uint _tokenId) external pure returns (string memory);\n}\n")),(0,r.kt)("p",null,"Add an instance inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"SVGRenderer")," contract for the ",(0,r.kt)("inlineCode",{parentName:"p"},"SeaRenderer"),", and a constructor that takes an address for the ",(0,r.kt)("inlineCode",{parentName:"p"},"SeaRenderer"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"constructor(address _seaRenderer) {\n  seaRenderer = ISVGPartRenderer(_seaRenderer);\n}\n")),(0,r.kt)("p",null,"Replace ",(0,r.kt)("inlineCode",{parentName:"p"},"// TODO: Add the sea,")," with a call to your external function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function render(uint _tokenId) public view returns (string memory) {\n  return string(\n    abi.encodePacked(\n      \"<SVG xmlns='http://www.w3.org/2000/SVG' viewBox='0 0 1024 1024'>\",\n      // TODO: Add the clouds,\n      // TODO: Add the sun,\n      // TODO: Add the land,\n      seaRenderer.render(),\n      // TODO: Add the background,\n      \"</SVG>\"\n    )\n  );\n}\n")),(0,r.kt)("h2",{id:"finishing-a-first-pass"},"Finishing a First Pass"),(0,r.kt)("p",null,"Return to your ",(0,r.kt)("inlineCode",{parentName:"p"},"LandSeaSkyNFT")," contract and add an ",(0,r.kt)("inlineCode",{parentName:"p"},"interface")," for the ",(0,r.kt)("inlineCode",{parentName:"p"},"SVGRenderer"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"interface ISVGRenderer {\n  function render(uint _tokenId) external view returns (string memory);\n}\n")),(0,r.kt)("p",null,"Add an instance of it and update the ",(0,r.kt)("inlineCode",{parentName:"p"},"constructor")," to set it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'ISVGRenderer SVGRenderer;\n\nconstructor(address _SVGRenderer) ERC721("Land, Sea, and Sky", "LSS") {\n  SVGRenderer = ISVGRenderer(_SVGRenderer);\n}\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"For testing purposes, it may be easier if you add functions to allow you to change these addresses after deployment. But the whole point of all this work is to make immutable, onchain NFTs, so be sure to delete them before you do your real deployment!")),(0,r.kt)("p",null,"Finally, swap your ",(0,r.kt)("inlineCode",{parentName:"p"},"TODO")," with a line to ",(0,r.kt)("inlineCode",{parentName:"p"},"Base64.encode")," a call to the renderer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Solidity"},'string memory json = Base64.encode(\n  bytes(\n    string(\n      abi.encodePacked(\n        \'{"name": "Land, Sea, and Sky #: \',\n        Strings.toString(tokenId),\n        \'", "description": "Land, Sea, and Sky is a collection of generative art pieces stored entirely onchain.", "image": "data:image/SVG+xml;base64,\',\n        Base64.encode(bytes(SVGRenderer.render(tokenId))),\n        \'"}\'\n      )\n    )\n  )\n);\n')),(0,r.kt)("h3",{id:"test-deploy"},"Test Deploy"),(0,r.kt)("p",null,"Now is a good time to deploy to testnet and see if this first pass is working as expected. If you're using ",(0,r.kt)("a",{parentName:"p",href:"https://docs.base.org/base-camp/docs/hardhat-deploy/hardhat-deploy-sbs"},"Hardhat and Hardhat Deploy"),", you can use this script:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"import { HardhatRuntimeEnvironment } from 'hardhat/types';\nimport { DeployFunction } from 'hardhat-deploy/types';\n\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  const { deployments, getNamedAccounts } = hre;\n  const { deploy } = deployments;\n  const { deployer } = await getNamedAccounts();\n\n  const SeaRenderer = await deploy('SeaRenderer', {\n    from: deployer,\n  });\n\n  const SVGRenderer = await deploy('SVGRenderer', {\n    from: deployer,\n    args: [SeaRenderer.address],\n  });\n\n  const LandSeaSkyNFT = await deploy('LandSeaSkyNFT', {\n    from: deployer,\n    args: [SVGRenderer.address],\n  });\n\n  await hre.run('verify:verify', {\n    address: LandSeaSkyNFT.address,\n    constructorArguments: [SVGRenderer.address],\n    contract: 'contracts/LandSeaSkyNFT.sol:LandSeaSkyNFT',\n  });\n};\nexport default func;\n")),(0,r.kt)("p",null,"Deploy the contracts to Base Sepolia and verify them, or at least verify ",(0,r.kt)("inlineCode",{parentName:"p"},"LandSeaSkyNFT")," (the above script will do this)."),(0,r.kt)("p",null,"Open the contract in ",(0,r.kt)("a",{parentName:"p",href:"https://sepolia.basescan.org/"},"Basescan"),", connect with your wallet, and mint some NFTs."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Wait a few minutes"),", then open the ",(0,r.kt)("a",{parentName:"p",href:"https://testnets.opensea.io/"},"testnet version of Opensea")," and look up your contract. It may take several minutes to show up, but when it does, if everything is working you'll see NFTs with the ocean part of the art! Neat!"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"First pass NFT",src:n(75496).Z,width:"1076",height:"394"})),(0,r.kt)("h2",{id:"adding-the-sky-renderer"},"Adding the Sky Renderer"),(0,r.kt)("p",null,"Great work! Much of the hardest part is done. All you need to do now is add a renderer for each of the other elements, with the twist that you'll be doing customization inside the SVGs themselves. You'll have to do a little surgery!"),(0,r.kt)("h3",{id:"preparing-the-svg"},"Preparing the SVG"),(0,r.kt)("p",null,"Open the sky SVG in both an editor, and the browser. As with for the sea, the first step is to change the viewport to 1024x1024, move the ",(0,r.kt)("inlineCode",{parentName:"p"},"<defs>")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"<style>")," elements inside the top-level ",(0,r.kt)("inlineCode",{parentName:"p"},"<g>"),", and transform/translate that group to the correct location (0,0 will work!)."),(0,r.kt)("p",null,"Change ",(0,r.kt)("inlineCode",{parentName:"p"},"cls-1")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"cls-sky-1")," in both the definition and where it's used. Add ",(0,r.kt)("inlineCode",{parentName:"p"},"sky")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"linear-gradient")," as well."),(0,r.kt)("p",null,"Delete the data and layer information for this group as well. You'll end up with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},'<svg xmlns="http://www.w3.org/2000/SVG" viewBox="0 0 1024 1024">\n  <g transform="translate(0,0)">\n    <defs>\n      <style>\n        cls-sky-1 {\n          fill: url(#linear-gradient-sky);\n          stroke-width: 0px;\n        }\n      </style>\n      <linearGradient\n        id="linear-gradient-sky"\n        x1="511.76"\n        y1="10.19"\n        x2="512.24"\n        y2="865.99"\n        gradientTransform="translate(63.89) scale(.88)"\n        gradientUnits="userSpaceOnUse"\n      >\n        <stop offset=".12" stop-color="#c391b4" />\n        <stop offset=".34" stop-color="#ce9f9b" />\n        <stop offset=".68" stop-color="#dfd061" />\n        <stop offset=".96" stop-color="#e3f9f7" />\n      </linearGradient>\n    </defs>\n    <path class="cls-sky-1" d="M1024,0v768.9H0V0h1024Z" />\n  </g>\n</svg>\n')),(0,r.kt)("p",null,"You have some design choices to make here. You could use deterministically chosen, but essentially random colors to make up the gradient. However, doing so will lead to the vast majority of NFTs having truly bizarre colors that don't look nice and don't look like they belong with the rest of the art."),(0,r.kt)("p",null,"No one wants their sky to be a mix of cyan, teal, maroon, and brown!"),(0,r.kt)("p",null,"It might be better to add a gentle modification to the existing gradient colors and range. Start by minifying the top level ",(0,r.kt)("inlineCode",{parentName:"p"},"<g>")," group and contents, then create ",(0,r.kt)("strong",{parentName:"p"},"two")," constant strings, one for everything before the first ",(0,r.kt)("inlineCode",{parentName:"p"},"<stop>")," element, and one for everything after the last ",(0,r.kt)("inlineCode",{parentName:"p"},"<stop>")," element."),(0,r.kt)("p",null,"Neither string should have the ",(0,r.kt)("inlineCode",{parentName:"p"},"<stop>"),"s. You'll make those next."),(0,r.kt)("h3",{id:"building-the-renderer-contract"},"Building the Renderer Contract"),(0,r.kt)("p",null,"Add a new file and contract called ",(0,r.kt)("inlineCode",{parentName:"p"},"SkyRenderer"),". Add your strings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport "hardhat/console.sol";\nimport "@openzeppelin/contracts/utils/Strings.sol";\n\nstring constant START = \'<g transform="translate(0,0)"> <defs> <style>.cls-sky-1{fill: url(#linear-gradient-sky); stroke-width: 0px;}</style> <linearGradient id="linear-gradient-sky" x1="511.76" y1="10.19" x2="512.24" y2="865.99" gradientTransform="translate(63.89) scale(.88)" gradientUnits="userSpaceOnUse">\';\nstring constant END = \'</linearGradient> </defs> <path class="cls-sky-1" d="M1024,0v768.9H0V0h1024Z"/> </g>\';\n\ncontract SkyRenderer {\n  function render(uint _tokenId) public pure returns (string memory) {\n    return //TODO;\n  }\n}\n')),(0,r.kt)("p",null,"Next, add constants for the existing ",(0,r.kt)("inlineCode",{parentName:"p"},"offset")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"stop-color")," properties:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'string constant OFFSET1 = ".12";\nstring constant OFFSET2 = ".34";\nstring constant OFFSET3 = ".68";\nstring constant OFFSET4 = ".96";\nstring constant COLOR1 = "#c391b4";\nstring constant COLOR2 = "#ce9f9b";\nstring constant COLOR3 = "#dfd061";\nstring constant COLOR4 = "#e3f9f7";\n')),(0,r.kt)("p",null,"Now, stub out your return for the ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," function. It will use the built in method of using ",(0,r.kt)("inlineCode",{parentName:"p"},"abi.encode")," and casting to ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," to combine all the parts and return them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function render(uint _tokenId) public pure returns (string memory) {\n  return string(\n    abi.encodePacked(\n      START,\n      // TODO stop 1,\n      // TODO stop 2,\n      // TODO stop 3,\n      // TODO stop 4,\n      END\n    )\n  );\n}\n")),(0,r.kt)("p",null,"Do the same for a function to ",(0,r.kt)("inlineCode",{parentName:"p"},"buildStop"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function _buildStop(\n    string memory _offset,\n    string memory _color,\n    uint _tokenId,\n    uint _stopNumber\n    ) internal pure returns (string memory) {\n    return string(\n      abi.encodePacked(\n        '<stop offset=\"',\n        // TODO tweaked offset,\n        '\" stop-color=\"',\n        _color,\n        '\"/>'\n      )\n    );\n  }\n")),(0,r.kt)("p",null,"Now, you just need to figure out how to modify the properties based on the ",(0,r.kt)("inlineCode",{parentName:"p"},"_tokenId"),'. It needs to be "random" in the sense that every NFT should be different, but it has to be deterministic, so that you get the same art every time you load the image.'),(0,r.kt)("p",null,"First, ",(0,r.kt)("strong",{parentName:"p"},"subtract 10")," from the values and convert them to ",(0,r.kt)("inlineCode",{parentName:"p"},"uints")," ",(0,r.kt)("strong",{parentName:"p"},"without")," decimals in each of your stop constants, and reduce the last to ",(0,r.kt)("inlineCode",{parentName:"p"},"80"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"uint constant OFFSET1 = 2;\nuint constant OFFSET2 = 24;\nuint constant OFFSET3 = 58;\nuint constant OFFSET4 = 80;\n")),(0,r.kt)("p",null,"You'll also need to update the parameter in ",(0,r.kt)("inlineCode",{parentName:"p"},"_buildStop"),"."),(0,r.kt)("p",null,"Add a function to ",(0,r.kt)("inlineCode",{parentName:"p"},"_buildOffsetValue"),". This will pick an integer between 0 and 20 for each offset, and add it to the modified offsets you just made. The result will be a change of + or 1 10 for each value (with the last being slightly different to keep it in range):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function _buildOffsetValue(\n    uint _offset,\n    uint _tokenId,\n    uint _stopNumber\n  ) internal pure returns (string memory) {\n  bytes32 hash = keccak256(abi.encodePacked(_offset, _tokenId, _stopNumber));\n  uint rand = uint(hash);\n  uint change = rand % 20; // Produces a number between 0 and 19\n  if(change >= 10) {\n    return string(\n      abi.encodePacked(\n        '.',\n        Strings.toString(_offset + change)\n      )\n    );\n  } else {\n      return string(\n      abi.encodePacked(\n        '.',\n        '0', // 9 is .09, not .9\n        Strings.toString(_offset + change)\n      )\n    );\n  }\n}\n")),(0,r.kt)("p",null,"This function uses hashing to create a pseudo-random number with the token id and stop as seeds, guaranteeing a consistent value, unique for each token and each stop within that token. It takes advantage of the way the offset property is interpreted - in this case, ",(0,r.kt)("inlineCode",{parentName:"p"},'".12+.20" == ".32"'),"."),(0,r.kt)("p",null,"Finally, update your ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," function to call ",(0,r.kt)("inlineCode",{parentName:"p"},"_buildStop"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function render(uint _tokenId) public pure returns (string memory) {\n  return string(\n    abi.encodePacked(\n      START,\n      _buildStop(OFFSET1, COLOR1, _tokenId, 1),\n      _buildStop(OFFSET2, COLOR2, _tokenId, 2),\n      _buildStop(OFFSET3, COLOR3, _tokenId, 3),\n      _buildStop(OFFSET4, COLOR4, _tokenId, 4),\n      END\n    )\n  );\n}\n")),(0,r.kt)("h3",{id:"incorporating-the-sky-renderer"},"Incorporating the Sky Renderer"),(0,r.kt)("p",null,"Return to ",(0,r.kt)("inlineCode",{parentName:"p"},"SVGRenderer.sol")," and add an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"ISVGPartRenderer")," for the skyRenderer. Add an argument to the ",(0,r.kt)("inlineCode",{parentName:"p"},"constructor")," and initialize it, then call the ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," function in place of your ",(0,r.kt)("inlineCode",{parentName:"p"},"TODO")," for the background."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport "hardhat/console.sol";\nimport "@openzeppelin/contracts/utils/Strings.sol";\n\ninterface ISVGPartRenderer {\n  function render() external pure returns (string memory);\n  function render(uint _tokenId) external pure returns (string memory);\n}\n\ncontract SVGRenderer {\n\n  ISVGPartRenderer seaRenderer;\n  ISVGPartRenderer skyRenderer;\n\n  constructor(address _seaRenderer, address _skyRenderer) {\n    seaRenderer = ISVGPartRenderer(_seaRenderer);\n    skyRenderer = ISVGPartRenderer(_skyRenderer);\n  }\n\n  function render(uint _tokenId) public view returns (string memory) {\n    return string(\n      abi.encodePacked(\n        "<SVG xmlns=\'http://www.w3.org/2000/SVG\' viewBox=\'0 0 1024 1024\'>",\n        // TODO: Add the clouds,\n        // TODO: Add the sun,\n        // TODO: Add the land,\n        skyRenderer.render(_tokenId),\n        seaRenderer.render(),\n        "</SVG>"\n      )\n    );\n  }\n}\n')),(0,r.kt)("p",null,"Update your deploy script, then deploy and test as before."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const SkyRenderer = await deploy('SkyRenderer', {\n  from: deployer,\n});\n\nconst SVGRenderer = await deploy('SVGRenderer', {\n  from: deployer,\n  args: [SeaRenderer.address, SkyRenderer.address],\n});\n")),(0,r.kt)("p",null,"Test as before. Your NFTs now have the sky!"),(0,r.kt)("h2",{id:"adding-the-landrenderer"},"Adding the LandRenderer"),(0,r.kt)("p",null,"Next up is the mountain part of the SVG. For this, you'll change the horizontal translation left to right to show a different part of the mountains for each NFT."),(0,r.kt)("h3",{id:"preparing-the-svg-1"},"Preparing the SVG"),(0,r.kt)("p",null,"Open the mountain SVG in both your browser and the editor. Once again, set the ",(0,r.kt)("inlineCode",{parentName:"p"},"viewBox")," to 1024x1024 and move the ",(0,r.kt)("inlineCode",{parentName:"p"},"<defs>")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"<styles>")," inside the top-level group (",(0,r.kt)("inlineCode",{parentName:"p"},"<g>"),")."),(0,r.kt)("p",null,"Find transform/translate values that first put the mountains so that they are at the bottom, and the left-most portion is shown, then the right-most. ",(0,r.kt)("inlineCode",{parentName:"p"},'transform="translate(-150,350)"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},'transform="translate(-800,350)"')," are about right."),(0,r.kt)("p",null,"Don't forget to add ",(0,r.kt)("inlineCode",{parentName:"p"},"-land")," to the classnames!"),(0,r.kt)("h3",{id:"writing-the-contract"},"Writing the Contract"),(0,r.kt)("p",null,"Add a file and stub for the ",(0,r.kt)("inlineCode",{parentName:"p"},"LandRenderer"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport "hardhat/console.sol";\nimport "@openzeppelin/contracts/utils/Strings.sol";\n\ncontract LandRenderer {\n  function render(uint _tokenId) public pure returns (string memory) {\n    return string(\n      abi.encodePacked(\n        \'<g transform="translate(\',\n        // TODO,\n        \',300)">\',\n        END\n      )\n    );\n  }\n}\n')),(0,r.kt)("p",null,"Minify the top-level ",(0,r.kt)("inlineCode",{parentName:"p"},"<g>")," element, and add a constant with everything after the opening ",(0,r.kt)("inlineCode",{parentName:"p"},"<g>")," tag. Use similar techniques as before to generate an offset based on the token id, then build the SVG. You'll end up with something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport "hardhat/console.sol";\nimport "@openzeppelin/contracts/utils/Strings.sol";\n\nstring constant END = "<long SVG string>";\n\ncontract LandRenderer {\n  function render(uint _tokenId) public pure returns (string memory) {\n    return string(\n      abi.encodePacked(\n        \'<g transform="translate(\',\n        _buildOffset(_tokenId),\n        \',300)">\',\n        END\n      )\n    );\n  }\n\n  function _buildOffset(uint _tokenId) internal pure returns (string memory) {\n    bytes32 hash = keccak256(abi.encodePacked(_tokenId));\n    uint rand = uint(hash);\n    uint xOffset = (rand % 650) + 150; // Produces a number between 150 and 799\n    return string(abi.encodePacked("-", Strings.toString(xOffset)));\n  }\n}\n')),(0,r.kt)("h3",{id:"incorporating-the-landrenderer"},"Incorporating the LandRenderer"),(0,r.kt)("p",null,"Update ",(0,r.kt)("inlineCode",{parentName:"p"},"SVGRenderer"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"ISVGPartRenderer seaRenderer;\nISVGPartRenderer skyRenderer;\nISVGPartRenderer landRenderer;\n\nconstructor(address _seaRenderer, address _skyRenderer, address _landRenderer) {\n  seaRenderer = ISVGPartRenderer(_seaRenderer);\n  skyRenderer = ISVGPartRenderer(_skyRenderer);\n  landRenderer = ISVGPartRenderer(_landRenderer);\n}\n\nfunction render(uint _tokenId) public view returns (string memory) {\n  return string(\n    abi.encodePacked(\n      \"<SVG xmlns='http://www.w3.org/2000/SVG' viewBox='0 0 1024 1024'>\",\n      skyRenderer.render(_tokenId),\n      landRenderer.render(_tokenId),\n      seaRenderer.render(),\n      \"</SVG>\"\n    )\n  );\n}\n")),(0,r.kt)("p",null,"And the deploy script:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const LandRenderer = await deploy('LandRenderer', {\n  from: deployer,\n});\n\nconst SVGRenderer = await deploy('SVGRenderer', {\n  from: deployer,\n  args: [SeaRenderer.address, SkyRenderer.address, LandRenderer.address],\n});\n")),(0,r.kt)("p",null,"Test as before. It's starting to look really nice!"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Progress",src:n(5406).Z,width:"1336",height:"761"})),(0,r.kt)("h2",{id:"adding-the-sun-renderer"},"Adding the Sun Renderer"),(0,r.kt)("p",null,"The sun renderer will use similar techniques as those you've already incorporated. The sun will be in the same place for all NFTs. Variation will come from each one having only one of the three suns shown in the exemplar art file."),(0,r.kt)("h3",{id:"preparing-the-svgs"},"Preparing the SVGs"),(0,r.kt)("p",null,"For each of the three sun SVGs:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Change the ",(0,r.kt)("inlineCode",{parentName:"li"},"viewBox")," to 1024x1024"),(0,r.kt)("li",{parentName:"ul"},"Move the ",(0,r.kt)("inlineCode",{parentName:"li"},"<defs>")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"<styles>")," into the first group"),(0,r.kt)("li",{parentName:"ul"},"Find the correct translation to put the sun in the upper right",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"750, 100 should work with the sample art"))),(0,r.kt)("li",{parentName:"ul"},"Add ",(0,r.kt)("inlineCode",{parentName:"li"},"-sun")," to the classnames")),(0,r.kt)("h3",{id:"writing-the-contracts"},"Writing the Contracts"),(0,r.kt)("p",null,"The tricky part here is that you can't fit all the suns into one contract. They're too big! Instead, split them into three, similar to the original ocean renderer. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\nimport "hardhat/console.sol";\nimport "@openzeppelin/contracts/utils/Strings.sol";\n\nstring constant SVG = \'<long SVG>\'\n\ncontract SunRenderer1 {\n  function render() public pure returns (string memory) {\n    return SVG;\n  }\n}\n')),(0,r.kt)("h3",{id:"incorporating-the-sunrenderer"},"Incorporating the SunRenderer"),(0,r.kt)("p",null,"Add the three ",(0,r.kt)("inlineCode",{parentName:"p"},"SunRenderer"),"s as you have the other rendering contracts. You'll have to incorporate this one a little differently. Add a function that picks which ",(0,r.kt)("inlineCode",{parentName:"p"},"SunRenderer")," to call, based on the NFT id."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function pickSunRenderer(uint _tokenId) public view returns (ISVGPartRenderer) {\n    bytes32 hash = keccak256(abi.encodePacked(_tokenId));\n    uint rand = uint(hash);\n    uint sun = rand % 3;\n    if(sun == 0) {\n      return sunRenderer1;\n    } else if(sun == 1) {\n      return sunRenderer2;\n    } else {\n      return sunRenderer3;\n    }\n  }\n")),(0,r.kt)("p",null,"Make sure to put it after ",(0,r.kt)("inlineCode",{parentName:"p"},"skyRenderer")," in the main ",(0,r.kt)("inlineCode",{parentName:"p"},"render")," function!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function render(uint _tokenId) public view returns (string memory) {\n  return string(\n    abi.encodePacked(\n      \"<SVG xmlns='http://www.w3.org/2000/SVG' viewBox='0 0 1024 1024'>\",\n      skyRenderer.render(_tokenId),\n      pickSunRenderer(_tokenId).render(),\n      landRenderer.render(_tokenId),\n      seaRenderer.render(),\n      \"</SVG>\"\n    )\n  );\n}\n")),(0,r.kt)("p",null,"Test it out. You've now got one of three suns in the sky for each NFT!"),(0,r.kt)("h2",{id:"adding-the-cloud-renderer"},"Adding the Cloud Renderer"),(0,r.kt)("p",null,"On your own, try adding the clouds. The clouds renderer should:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Randomly select between one and seven clouds"),(0,r.kt)("li",{parentName:"ul"},"Place those clouds randomly on the top half of the canvas"),(0,r.kt)("li",{parentName:"ul"},"Be on the layer on top of the sun and sky, but below the sea and mountains")),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"In this tutorial, you've learned how to take advantage of the fact that offchain calls to your smart contracts don't use gas to create a significantly complex system to render complicated and unique NFTs, with the metadata and art existing entirely onchain. You've also explored some techniques for creating deterministic, pseudorandom numbers, and how to use them to add variation to your art. You've dealt with some of the many caveats and quirks of programmatically combining SVG files. Finally, you've practiced building multiple contracts that interact with one another."),(0,r.kt)("hr",null))}c.isMDXComponent=!0},92695:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/architecture-728cc9f274fd1674c5d6eb05142c0bb0.png"},75496:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/first_pass-29c2202581ede5f7bed1a34fb85cd051.png"},456:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/mockup-8ebcf2230405498ad52a788c1950c70b.png"},5406:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/progress-b806168544eb55f22e2fae91b9556936.png"}}]);