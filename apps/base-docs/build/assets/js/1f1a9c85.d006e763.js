"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[6707],{30876:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>p});var n=a(2784);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},h="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=l(a),d=o,p=h["".concat(c,".").concat(d)]||h[d]||m[d]||r;return a?n.createElement(p,i(i({ref:t},u),{},{components:a})):n.createElement(p,i({ref:t},u))}));function p(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},64197:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var n=a(7896),o=(a(2784),a(30876));const r={title:"EVM Diagram",description:"An overview of the Ethereum Virtual Machine",hide_table_of_contents:!1},i=void 0,s={unversionedId:"docs/ethereum-virtual-machine/evm-diagram",id:"docs/ethereum-virtual-machine/evm-diagram",title:"EVM Diagram",description:"An overview of the Ethereum Virtual Machine",source:"@site/base-camp/docs/ethereum-virtual-machine/evm-diagram.md",sourceDirName:"docs/ethereum-virtual-machine",slug:"/docs/ethereum-virtual-machine/evm-diagram",permalink:"/base-camp/docs/ethereum-virtual-machine/evm-diagram",draft:!1,tags:[],version:"current",frontMatter:{title:"EVM Diagram",description:"An overview of the Ethereum Virtual Machine",hide_table_of_contents:!1}},c={},l=[{value:"Objectives",id:"objectives",level:2},{value:"What is the EVM?",id:"what-is-the-evm",level:2},{value:"EVM Components",id:"evm-components",level:2},{value:"EVM Execution Model",id:"evm-execution-model",level:2},{value:"Gas and Opcode Execution",id:"gas-and-opcode-execution",level:2},{value:"Stack and Memory",id:"stack-and-memory",level:2},{value:"EVM Architecture and Execution Context",id:"evm-architecture-and-execution-context",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"See Also",id:"see-also",level:2}],u={toc:l},h="wrapper";function m(e){let{components:t,...r}=e;return(0,o.kt)(h,(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In this article, we'll examine the inner workings of the EVM, its components, and its role within the Ethereum network."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"objectives"},"Objectives"),(0,o.kt)("p",null,"By the end of this lesson you should be able to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Diagram the EVM")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"what-is-the-evm"},"What is the EVM?"),(0,o.kt)("p",null,"The Ethereum Virtual Machine (EVM) is the core engine of Ethereum. It is a Turing-complete, sandboxed virtual machine designed to execute smart contracts on the network. The term \"sandboxed\" means that the EVM operates in an isolated environment, ensuring that each smart contract's execution does not interfere with others or the underlying blockchain. As we've learned, the EVM's Turing-complete nature allows developers to write complex programs that can perform any computationally feasible task."),(0,o.kt)("p",null,"The EVM employs a sophisticated resource management system using gas to regulate computation costs and prevent network abuse. It also supports a rich ecosystem of apps by providing a versatile set of opcodes for smart contract logic, and fostering interoperability with various programming languages, tools, and technologies. This adaptability has made the EVM a fundamental component in the advancement and growth of the Ethereum network."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"evm-components"},"EVM Components"),(0,o.kt)("p",null,"The EVM has several key components that enable it to process and manage smart contracts. Let's define them:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"World State:")," Represents the entire Ethereum network, including all accounts and their associated storage."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Accounts:")," Entities that interact with the Ethereum network, including Externally Owned Accounts (EOAs) and Contract Accounts."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Storage:")," A key-value store associated with each contract account, containing the contract's state and data."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Gas:")," A mechanism for measuring the cost of executing operations in the EVM, which protects the network from spam and abuse."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Opcodes:")," Low-level instructions that the EVM executes during smart contract processing."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Execution Stack:")," A last-in, first-out (LIFO) data structure for temporarily storing values during opcode execution."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Memory:")," A runtime memory used by smart contracts during execution."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Program Counter:")," A register that keeps track of the position of the next opcode to be executed."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Logs:")," Events emitted by smart contracts during execution, which can be used by external systems for monitoring or reacting to specific events.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"evm-execution-model"},"EVM Execution Model"),(0,o.kt)("p",null,"In simple terms, when a transaction is submitted to the network, the EVM first verifies its validity. If the transaction is deemed valid, the EVM establishes an execution context that incorporates the current state of the network and processes the smart contract's bytecode using opcodes. As the EVM runs the smart contract, it modifies the blockchain's world state and consumes gas accordingly. However, if the transaction is found to be invalid, it will be dismissed by the network without further processing. Throughout the smart contract's execution, logs are generated that provide insights into the contract's performance and any emitted events. These logs can be utilized by external systems for monitoring purposes or to respond to specific events."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"EVM Execution Model",src:a(36216).Z,width:"1000",height:"500"})),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"gas-and-opcode-execution"},"Gas and Opcode Execution"),(0,o.kt)("p",null,"While we have already delved into the concept of gas in a previous lesson, it is worth reiterating its critical role within the EVM and as a fundamental component of Ethereum. Gas functions as a metric for quantifying the computational effort needed to carry out operations in the EVM. Every opcode in a smart contract carries a specific gas cost, which reflects the computational resources necessary for its execution."),(0,o.kt)("p",null,"Opcodes are the low-level instructions executed by the EVM. They represent elementary operations that allow the EVM to process and manage smart contracts."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Opcode Execution",src:a(20224).Z,width:"1000",height:"500"})),(0,o.kt)("p",null,"During execution, the EVM reads opcodes from the smart contract, and depending on the opcode, it may update the world state, consume gas, or revert the state if an error occurs. Some common opcodes include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"ADD:")," Adds two values from the stack."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"SUB:")," Subtracts two values from the stack."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"MSTORE:")," Stores a value in memory."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"SSTORE:")," Stores a value in contract storage."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"CALL:")," Calls another contract or sends ether.")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"stack-and-memory"},"Stack and Memory"),(0,o.kt)("p",null,"The EVM stack and memory are critical components of the EVM architecture, as they enable smart contracts to manage temporary data during opcode execution. The stack is a last-in, first-out (LIFO) data structure that is used for temporarily storing values during opcode execution. It is managed by the EVM and is separate from the contract's storage. The stack supports two primary operations: push and pop."),(0,o.kt)("p",null,"The push operation adds a value to the top of the stack, while the pop operation removes the top value from the stack. These operations are used to manage temporary data during opcode execution. For example, an opcode that performs an addition operation might push the two operands onto the stack, perform the addition, and then pop the result off the top of the stack."),(0,o.kt)("p",null,"During contract execution, memory serves as a collection of bytes, organized in an array, for the purpose of temporarily storing data. It can be read from and written to by opcodes. Memory is often used to store temporary data during opcode execution, such as when working with dynamically sized data like strings or arrays that are being manipulated or computed within the smart contract before being stored in the contract's storage. When a smart contract needs to store temporary data during opcode execution, it can use the memory to store that data."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"EVM Stack and Memory",src:a(47599).Z,width:"1024",height:"768"})),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"evm-architecture-and-execution-context"},"EVM Architecture and Execution Context"),(0,o.kt)("p",null,"To fully grasp the EVM architecture and its components, it's important to see how they all come together in a cohesive manner. The following diagram provides an in-depth visualization of the EVM architecture, showcasing the interactions between key elements such as transactions, gas, opcodes, and the world state. With this diagram, you can see how each component plays a vital role in the seamless execution of smart contracts on the Ethereum network."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Figure 13-1. EVM architecture and execution context.",src:a(39989).Z,width:"1500",height:"1200"}),"\nImage Source: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ethereumbook/ethereumbook"},"Mastering Ethereum")," by Andreas M. Antonopoulos and Gavin Wood, licensed under ",(0,o.kt)("a",{parentName:"p",href:"https://creativecommons.org/licenses/by-sa/4.0/"},"CC BY-SA 4.0")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"The EVM plays a vital role within the Ethereum network. By examining the EVM's key components as well as its architecture and execution model, we've gained insight into the engine of Ethereum and how it enables the smooth execution of smart contracts on the platform."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"see-also"},"See Also"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://cypherpunks-core.github.io/ethereumbook/13evm.html#evm_architecture"},"The Ethereum Virtual Machine (Mastering Ethereum)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://ethereum.org/en/developers/docs/evm/"},"Ethereum Virtual Machine (Ethereum docs)"))))}m.isMDXComponent=!0},39989:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/evm-architecture-execution-b6fc2111dc4e40673039c3afc2acd2c8.png"},36216:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/evm-execution-basic-cab88f34b65761dff7d10b9acfd9533f.png"},47599:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/evm-stack-memory-3edfc9903de824835d9c8e89f4c48d63.png"},20224:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/opcode-execution-20224ffe096be35c136650e205e68873.png"}}]);