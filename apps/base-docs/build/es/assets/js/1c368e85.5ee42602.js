"use strict";(self.webpackChunk_app_base_docs=self.webpackChunk_app_base_docs||[]).push([[653],{30876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var a=n(2784);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),h=c(n),p=o,g=h["".concat(s,".").concat(p)]||h[p]||d[p]||r;return n?a.createElement(g,i(i({ref:t},u),{},{components:n})):a.createElement(g,i({ref:t},u))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},39695:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var a=n(7896),o=(n(2784),n(30876));const r={title:"Hardhat: Analyzing the test coverage of smart contracts",slug:"/hardhat-test-coverage",description:"A tutorial that teaches how to profile the test coverage of your smart contracts using Hardhat and the Solidity Coverage plugin.",author:"Edson Alcala",keywords:["Solidity Coverage","Smart Contract Testing","Test Coverage","Base network","Base blockchain","blockchain development","Hardhat","Solidity","Code Testing","Test Suite Analysis"],tags:["smart contracts"],difficulty:"beginner",hide_table_of_contents:!1,displayed_sidebar:null},i=void 0,l={unversionedId:"docs/hardhat-test-coverage",id:"docs/hardhat-test-coverage",title:"Hardhat: Analyzing the test coverage of smart contracts",description:"A tutorial that teaches how to profile the test coverage of your smart contracts using Hardhat and the Solidity Coverage plugin.",source:"@site/tutorials/docs/4_hardhat-test-coverage.md",sourceDirName:"docs",slug:"/hardhat-test-coverage",permalink:"/es/tutorials/hardhat-test-coverage",draft:!1,tags:[{label:"smart contracts",permalink:"/es/tutorials/tags/smart-contracts"}],version:"current",sidebarPosition:4,frontMatter:{title:"Hardhat: Analyzing the test coverage of smart contracts",slug:"/hardhat-test-coverage",description:"A tutorial that teaches how to profile the test coverage of your smart contracts using Hardhat and the Solidity Coverage plugin.",author:"Edson Alcala",keywords:["Solidity Coverage","Smart Contract Testing","Test Coverage","Base network","Base blockchain","blockchain development","Hardhat","Solidity","Code Testing","Test Suite Analysis"],tags:["smart contracts"],difficulty:"beginner",hide_table_of_contents:!1,displayed_sidebar:null}},s={},c=[{value:"Objectives",id:"objectives",level:2},{value:"Overview",id:"overview",level:2},{value:"Setting up the Solidity Coverage plugin",id:"setting-up-the-solidity-coverage-plugin",level:2},{value:"My first test coverage",id:"my-first-test-coverage",level:2},{value:"Increasing test coverage",id:"increasing-test-coverage",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"See also",id:"see-also",level:2}],u={toc:c},h="wrapper";function d(e){let{components:t,...r}=e;return(0,o.kt)(h,(0,a.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In this tutorial, you'll learn how to profile the test coverage of your smart contracts with ",(0,o.kt)("a",{parentName:"p",href:"https://hardhat.org/"},"Hardhat")," and the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/sc-forks/solidity-coverage"},"Solidity Coverage")," community plugin."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"objectives"},"Objectives"),(0,o.kt)("p",null,"By the end of this tutorial, you should be able to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Use the Solidity Coverage plugin to analyze the coverage of your test suite"),(0,o.kt)("li",{parentName:"ul"},"Increase the coverage of your test suite")),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"The Solidity Coverage plugin allows you to analyze and visualize the coverage of your smart contracts' test suite. This enables you to see what portions of your smart contract are being tested and what areas may have been overlooked. It's an indispensable plugin for developers seeking to fortify their testing practices and ensure robust smart contract functionality."),(0,o.kt)("h2",{id:"setting-up-the-solidity-coverage-plugin"},"Setting up the Solidity Coverage plugin"),(0,o.kt)("p",null,"The Solidity Coverage plugin is integrated into the Hardhat toolbox package, which is installed by default when you use the ",(0,o.kt)("inlineCode",{parentName:"p"},"npx hardhat init")," command."),(0,o.kt)("p",null,"To install manually, run ",(0,o.kt)("inlineCode",{parentName:"p"},"npm install -D solidity-coverage"),"."),(0,o.kt)("p",null,"Then, import ",(0,o.kt)("inlineCode",{parentName:"p"},"solidity-coverage")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"hardhat.config.ts"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'import "solidity-coverage"\n')),(0,o.kt)("p",null,"Once the installation completes either manually or via the default Hardhat template, the task ",(0,o.kt)("inlineCode",{parentName:"p"},"coverage")," becomes available via the ",(0,o.kt)("inlineCode",{parentName:"p"},"npx hardhat coverage")," command."),(0,o.kt)("h2",{id:"my-first-test-coverage"},"My first test coverage"),(0,o.kt)("p",null,"Review the following contract and test suite (You'll recognize these if you completed the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.base.org/base-camp/docs/hardhat-testing/hardhat-testing-sbs"},"Hardhat testing lesson")," in our ",(0,o.kt)("a",{parentName:"p",href:"https://base.org/camp"},"Basecamp")," series)."),(0,o.kt)("p",null,"Contract:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\ncontract Lock {\n    uint public unlockTime;\n    address payable public owner;\n\n    event Withdrawal(uint amount, uint when);\n\n    constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp < _unlockTime,\n            "Unlock time should be in the future"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n    }\n\n    function withdraw() public {\n        require(block.timestamp >= unlockTime, "You can\'t withdraw yet");\n        require(msg.sender == owner, "You aren\'t the owner");\n\n        emit Withdrawal(address(this).balance, block.timestamp);\n\n        owner.transfer(address(this).balance);\n    }\n}\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Lock.test.ts"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"import { expect } from \"chai\";\nimport { ethers } from \"hardhat\";\nimport { time } from \"@nomicfoundation/hardhat-network-helpers\";\nimport { SignerWithAddress } from '@nomicfoundation/hardhat-ethers/signers'\nimport { Lock__factory, Lock} from '../typechain-types'\n\ndescribe(\"Lock Tests\", function () {\n  const UNLOCK_TIME = 10000;\n  const VALUE_LOCKED = ethers.parseEther(\"0.01\");\n\n  let lastBlockTimeStamp: number;\n  let lockInstance: Lock;\n  let ownerSigner: SignerWithAddress\n  let otherUserSigner: SignerWithAddress;\n\n  before(async() => {\n    lastBlockTimeStamp = await time.latest()\n    const signers = await ethers.getSigners()\n    ownerSigner = signers[0]\n    otherUserSigner= signers[1]\n\n    const unlockTime = lastBlockTimeStamp + UNLOCK_TIME;\n\n    lockInstance = await new Lock__factory(ownerSigner).deploy(unlockTime, {\n      value: VALUE_LOCKED\n    })\n  })\n\n\n  it('should get the unlockTime value', async() => {\n    const unlockTime = await lockInstance.unlockTime();\n\n    expect(unlockTime).to.equal(lastBlockTimeStamp + UNLOCK_TIME)\n  })\n\n  it('should have the right ether balance', async() => {\n    const lockInstanceAddress = await lockInstance.getAddress()\n\n    const contractBalance = await ethers.provider.getBalance(lockInstanceAddress)\n\n    expect(contractBalance).to.equal(VALUE_LOCKED)\n  })\n\n  it('should have the right owner', async()=> {\n    expect(await lockInstance.owner()).to.equal(ownerSigner.address)\n  })\n\n  it('should not allow to withdraw before unlock time', async()=> {\n    await expect(lockInstance.withdraw()).to.be.revertedWith(\"You can't withdraw yet\")\n  })\n\n  it('should not allow to withdraw a non owner', async()=> {\n    const newLastBlockTimeStamp = await time.latest()\n\n    await time.setNextBlockTimestamp(newLastBlockTimeStamp + UNLOCK_TIME)\n\n    const newInstanceUsingAnotherSigner = lockInstance.connect(otherUserSigner)\n\n    await expect(newInstanceUsingAnotherSigner.withdraw()).to.be.revertedWith(\"You aren't the owner\")\n  })\n\n it('should allow to withdraw a owner', async()=> {\n    const balanceBefore = await ethers.provider.getBalance(await lockInstance.getAddress());\n\n    expect(balanceBefore).to.equal(VALUE_LOCKED)\n\n    const newLastBlockTimeStamp = await time.latest()\n\n    await time.setNextBlockTimestamp(newLastBlockTimeStamp + UNLOCK_TIME)\n\n    await lockInstance.withdraw();\n\n    const balanceAfter = await ethers.provider.getBalance(await lockInstance.getAddress());\n    expect(balanceAfter).to.equal(0)\n  })\n});\n")),(0,o.kt)("p",null,"If you run ",(0,o.kt)("inlineCode",{parentName:"p"},"npx hardhat coverage"),", you should get:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-terminal"}," Lock Tests\n    \u2714 should get the unlockTime value\n    \u2714 should have the right ether balance\n    \u2714 should have the right owner\n    \u2714 shouldn't allow to withdraw before unlock time\n    \u2714 shouldn't allow to withdraw a non owner\n    \u2714 should allow to withdraw a owner\n\n\n  6 passing (195ms)\n\n------------|----------|----------|----------|----------|----------------|\nFile        |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |\n------------|----------|----------|----------|----------|----------------|\n contracts/ |      100 |    83.33 |      100 |      100 |                |\n  Lock.sol  |      100 |    83.33 |      100 |      100 |                |\n------------|----------|----------|----------|----------|----------------|\nAll files   |      100 |    83.33 |      100 |      100 |                |\n------------|----------|----------|----------|----------|----------------|\n")),(0,o.kt)("p",null,"Which then gives you a report of the test coverage of your test suite. Notice there is a new folder called ",(0,o.kt)("inlineCode",{parentName:"p"},"coverage"),", which was generated by the ",(0,o.kt)("inlineCode",{parentName:"p"},"solidity-coverage")," plugin. Inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"coverage")," folder there is a ",(0,o.kt)("inlineCode",{parentName:"p"},"index.html")," file. Open it in a browser, you'll see a report similar to the following:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Coverage report",src:n(14801).Z,width:"1200",height:"586"})),(0,o.kt)("h2",{id:"increasing-test-coverage"},"Increasing test coverage"),(0,o.kt)("p",null,"Although the coverage of the previous test suite is almost perfect, there is one missing branch when creating the contract. Because you have not tested the condition that the ",(0,o.kt)("inlineCode",{parentName:"p"},"_unlockTime")," has to be greater than the ",(0,o.kt)("inlineCode",{parentName:"p"},"block.timestamp"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},'require(\n    block.timestamp < _unlockTime,\n    "Unlock time should be in the future"\n  );\n')),(0,o.kt)("p",null,"In order to increase the coverage, include a new test with the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  it('should verify the unlock time to be in the future', async () => {\n    const newLockInstance = new Lock__factory(ownerSigner).deploy(lastBlockTimeStamp, {\n      value: VALUE_LOCKED\n    })\n\n    await expect(newLockInstance).to.be.revertedWith(\"Unlock time should be in the future\")\n  })\n")),(0,o.kt)("p",null,"Then, run ",(0,o.kt)("inlineCode",{parentName:"p"},"npx hardhat coverage")," and you should get:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-solidity"},"  Lock Tests\n    \u2714 should verify the unlock time to be in the future (39ms)\n    \u2714 should get the unlockTime value\n    \u2714 should have the right ether balance\n    \u2714 should have the right owner\n    \u2714 shouldn't allow to withdraw before unlock time\n    \u2714 shouldn't allow to withdraw a non owner\n    \u2714 should allow to withdraw a owner\n\n\n  7 passing (198ms)\n\n------------|----------|----------|----------|----------|----------------|\nFile        |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |\n------------|----------|----------|----------|----------|----------------|\n contracts/ |      100 |      100 |      100 |      100 |                |\n  Lock.sol  |      100 |      100 |      100 |      100 |                |\n------------|----------|----------|----------|----------|----------------|\nAll files   |      100 |      100 |      100 |      100 |                |\n------------|----------|----------|----------|----------|----------------|\n")),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"In this tutorial, you've learned how to profile and analyze the test coverage of your smart contracts' test suite. You learned how to visualize the coverage report and improve the coverage of the test suite by using the Solidity Coverage plugin."),(0,o.kt)("hr",null),(0,o.kt)("h2",{id:"see-also"},"See also"))}d.isMDXComponent=!0},14801:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/coverage-report-798bbaa6356a5491faeca4ae71000d35.png"}}]);